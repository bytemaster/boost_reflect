<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Boost IDL Library: boost/idl/fast_delegate.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>boost/idl/fast_delegate.hpp</h1><a href="fast__delegate_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/**</span>
<a name="l00002"></a>00002 <span class="comment"> * @file fast_delegate.hpp</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * This class is used in place of boost::function&lt;&gt; because boost::function depends upon</span>
<a name="l00005"></a>00005 <span class="comment"> * RTTI</span>
<a name="l00006"></a>00006 <span class="comment"> *</span>
<a name="l00007"></a>00007 <span class="comment"> */</span>
<a name="l00008"></a>00008 
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 <span class="comment">//                      fast_delegate.hpp</span>
<a name="l00011"></a>00011 <span class="comment">//  Efficient delegates in C++ that generate only two lines of asm code!</span>
<a name="l00012"></a>00012 <span class="comment">//  Documentation is found at http://www.codeproject.com/cpp/fast_delegate.asp</span>
<a name="l00013"></a>00013 <span class="comment">//</span>
<a name="l00014"></a>00014 <span class="comment">//                      - Don Clugston, Mar 2004.</span>
<a name="l00015"></a>00015 <span class="comment">//      Major contributions were made by Jody Hagins.</span>
<a name="l00016"></a>00016 <span class="comment">// History:</span>
<a name="l00017"></a>00017 <span class="comment">// 24-Apr-04 1.0  * Submitted to CodeProject. </span>
<a name="l00018"></a>00018 <span class="comment">// 28-Apr-04 1.1  * Prevent most unsafe uses of evil static function hack.</span>
<a name="l00019"></a>00019 <span class="comment">//                * Improved syntax for horrible_cast (thanks Paul Bludov).</span>
<a name="l00020"></a>00020 <span class="comment">//                * Tested on Metrowerks MWCC and Intel ICL (IA32)</span>
<a name="l00021"></a>00021 <span class="comment">//                * Compiled, but not run, on Comeau C++ and Intel Itanium ICL.</span>
<a name="l00022"></a>00022 <span class="comment">//  27-Jun-04 1.2 * Now works on Borland C++ Builder 5.5</span>
<a name="l00023"></a>00023 <span class="comment">//                * Now works on /clr &quot;managed C++&quot; code on VC7, VC7.1</span>
<a name="l00024"></a>00024 <span class="comment">//                * Comeau C++ now compiles without warnings.</span>
<a name="l00025"></a>00025 <span class="comment">//                * Prevent the virtual inheritance case from being used on </span>
<a name="l00026"></a>00026 <span class="comment">//                    VC6 and earlier, which generate incorrect code.</span>
<a name="l00027"></a>00027 <span class="comment">//                * Improved warning and error messages. Non-standard hacks</span>
<a name="l00028"></a>00028 <span class="comment">//                   now have compile-time checks to make them safer.</span>
<a name="l00029"></a>00029 <span class="comment">//                * implicit_cast used instead of static_cast in many cases.</span>
<a name="l00030"></a>00030 <span class="comment">//                * If calling a const member function, a const class pointer can be used.</span>
<a name="l00031"></a>00031 <span class="comment">//                * make_fast_delegate() global helper function added to simplify pass-by-value.</span>
<a name="l00032"></a>00032 <span class="comment">//                * Added fastdelegate.clear()</span>
<a name="l00033"></a>00033 <span class="comment">// 16-Jul-04 1.2.1* Workaround for gcc bug (const member function pointers in templates)</span>
<a name="l00034"></a>00034 <span class="comment">// 30-Oct-04 1.3  * Support for (non-void) return values.</span>
<a name="l00035"></a>00035 <span class="comment">//                * No more workarounds in client code!</span>
<a name="l00036"></a>00036 <span class="comment">//                   MSVC and Intel now use a clever hack invented by John Dlugosz:</span>
<a name="l00037"></a>00037 <span class="comment">//                   - The FASTDELEGATEDECLARE workaround is no longer necessary.</span>
<a name="l00038"></a>00038 <span class="comment">//                   - No more warning messages for VC6</span>
<a name="l00039"></a>00039 <span class="comment">//                * Less use of macros. Error messages should be more comprehensible.</span>
<a name="l00040"></a>00040 <span class="comment">//                * Added include guards</span>
<a name="l00041"></a>00041 <span class="comment">//                * Added fast_delegate::empty() to test if invocation is safe (Thanks Neville Franks).</span>
<a name="l00042"></a>00042 <span class="comment">//                * Now tested on VS 2005 Express Beta, PGI C++</span>
<a name="l00043"></a>00043 <span class="comment">// 24-Dec-04 1.4  * Added delegate_memento, to allow collections of disparate delegates.</span>
<a name="l00044"></a>00044 <span class="comment">//                * &lt;,&gt;,&lt;=,&gt;= comparison operators to allow storage in ordered containers.</span>
<a name="l00045"></a>00045 <span class="comment">//                * Substantial reduction of code size, especially the &#39;Closure&#39; class.</span>
<a name="l00046"></a>00046 <span class="comment">//                * Standardised all the compiler-specific workarounds.</span>
<a name="l00047"></a>00047 <span class="comment">//                * MFP conversion now works for CodePlay (but not yet supported in the full code).</span>
<a name="l00048"></a>00048 <span class="comment">//                * Now compiles without warnings on _any_ supported compiler, including BCC 5.5.1</span>
<a name="l00049"></a>00049 <span class="comment">//                * New syntax: fast_delegate&lt; int (char *, double) &gt;. </span>
<a name="l00050"></a>00050 <span class="comment">// 14-Feb-05 1.4.1* Now treats =0 as equivalent to .clear(), ==0 as equivalent to .empty(). (Thanks elfric).</span>
<a name="l00051"></a>00051 <span class="comment">//                * Now tested on Intel ICL for AMD64, VS2005 Beta for AMD64 and Itanium.</span>
<a name="l00052"></a>00052 <span class="comment">// 30-Mar-05 1.5  * Safebool idiom: &quot;if (dg)&quot; is now equivalent to &quot;if (!dg.empty())&quot;</span>
<a name="l00053"></a>00053 <span class="comment">//                * Fully supported by CodePlay VectorC</span>
<a name="l00054"></a>00054 <span class="comment">//                * Bugfix for Metrowerks: empty() was buggy because a valid MFP can be 0 on MWCC!</span>
<a name="l00055"></a>00055 <span class="comment">//                * More optimal assignment,== and != operators for static function pointers.</span>
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 <span class="preprocessor">#ifndef _AOA_FASTDELEGATE_H</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span><span class="preprocessor">#define _AOA_FASTDELEGATE_H</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span>
<a name="l00060"></a>00060 <span class="preprocessor">#include &lt;string.h&gt;</span> <span class="comment">// to allow &lt;,&gt; comparisons</span>
<a name="l00061"></a>00061 <span class="keyword">namespace </span>boost { <span class="keyword">namespace </span>idl {
<a name="l00062"></a>00062 
<a name="l00063"></a>00063 <span class="preprocessor">#if _MSC_VER &gt; 1000</span>
<a name="l00064"></a>00064 <span class="preprocessor"></span><span class="preprocessor">#pragma once</span>
<a name="l00065"></a>00065 <span class="preprocessor"></span><span class="preprocessor">#endif // _MSC_VER &gt; 1000</span>
<a name="l00066"></a>00066 <span class="preprocessor"></span>
<a name="l00067"></a>00067 <span class="comment">//#include &lt;memory.h&gt; // to allow &lt;,&gt; comparisons</span>
<a name="l00068"></a>00068 <span class="comment"></span>
<a name="l00069"></a>00069 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00070"></a>00070 <span class="comment"></span><span class="comment">//                      Configuration options</span>
<a name="l00071"></a>00071 <span class="comment">//</span><span class="comment"></span>
<a name="l00072"></a>00072 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00073"></a>00073 <span class="comment"></span>
<a name="l00074"></a>00074 <span class="comment">// Uncomment the following #define for optimally-sized delegates.</span>
<a name="l00075"></a>00075 <span class="comment">// In this case, the generated asm code is almost identical to the code you&#39;d get</span>
<a name="l00076"></a>00076 <span class="comment">// if the compiler had native support for delegates.</span>
<a name="l00077"></a>00077 <span class="comment">// It will not work on systems where sizeof(dataptr) &lt; sizeof(codeptr). </span>
<a name="l00078"></a>00078 <span class="comment">// Thus, it will not work for DOS compilers using the medium model.</span>
<a name="l00079"></a>00079 <span class="comment">// It will also probably fail on some DSP systems.</span>
<a name="l00080"></a><a class="code" href="fast__delegate_8hpp.html#a32543cbcde64e264172b05087b344432">00080</a> <span class="preprocessor">#define FASTDELEGATE_USESTATICFUNCTIONHACK</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span>
<a name="l00082"></a>00082 <span class="comment">// Uncomment the next line to allow function declarator syntax.</span>
<a name="l00083"></a>00083 <span class="comment">// It is automatically enabled for those compilers where it is known to work.</span>
<a name="l00084"></a><a class="code" href="fast__delegate_8hpp.html#aeab859c756467654f55ca4f361cb3d97">00084</a> <span class="preprocessor">#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX</span>
<a name="l00085"></a>00085 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00086"></a>00086 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00087"></a>00087 <span class="comment"></span><span class="comment">//                      Compiler identification for workarounds</span>
<a name="l00088"></a>00088 <span class="comment">//</span><span class="comment"></span>
<a name="l00089"></a>00089 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00090"></a>00090 <span class="comment"></span>
<a name="l00091"></a>00091 <span class="comment">// Compiler identification. It&#39;s not easy to identify Visual C++ because</span>
<a name="l00092"></a>00092 <span class="comment">// many vendors fraudulently define Microsoft&#39;s identifiers.</span>
<a name="l00093"></a>00093 <span class="preprocessor">#if defined(_MSC_VER) &amp;&amp; !defined(__MWERKS__) &amp;&amp; !defined(__VECTOR_C) &amp;&amp; !defined(__ICL) &amp;&amp; !defined(__BORLANDC__)</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span><span class="preprocessor">#define FASTDLGT_ISMSVC</span>
<a name="l00095"></a>00095 <span class="preprocessor"></span>
<a name="l00096"></a>00096 <span class="preprocessor">#if (_MSC_VER &lt;1300) // Many workarounds are required for VC6.</span>
<a name="l00097"></a>00097 <span class="preprocessor"></span><span class="preprocessor">#define FASTDLGT_VC6</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span><span class="preprocessor">#pragma warning(disable:4786) // disable this ridiculous warning</span>
<a name="l00099"></a>00099 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span>
<a name="l00101"></a>00101 <span class="preprocessor">#endif</span>
<a name="l00102"></a>00102 <span class="preprocessor"></span>
<a name="l00103"></a>00103 <span class="comment">// Does the compiler uses Microsoft&#39;s member function pointer structure?</span>
<a name="l00104"></a>00104 <span class="comment">// If so, it needs special treatment.</span>
<a name="l00105"></a>00105 <span class="comment">// Metrowerks CodeWarrior, Intel, and CodePlay fraudulently define Microsoft&#39;s </span>
<a name="l00106"></a>00106 <span class="comment">// identifier, _MSC_VER. We need to filter Metrowerks out.</span>
<a name="l00107"></a>00107 <span class="preprocessor">#if defined(_MSC_VER) &amp;&amp; !defined(__MWERKS__)</span>
<a name="l00108"></a>00108 <span class="preprocessor"></span><span class="preprocessor">#define FASTDLGT_MICROSOFT_MFP</span>
<a name="l00109"></a>00109 <span class="preprocessor"></span>
<a name="l00110"></a>00110 <span class="preprocessor">#if !defined(__VECTOR_C)</span>
<a name="l00111"></a>00111 <span class="preprocessor"></span><span class="comment">// CodePlay doesn&#39;t have the __single/multi/virtual_inheritance keywords</span>
<a name="l00112"></a>00112 <span class="preprocessor">#define FASTDLGT_HASINHERITANCE_KEYWORDS</span>
<a name="l00113"></a>00113 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00114"></a>00114 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00115"></a>00115 <span class="preprocessor"></span>
<a name="l00116"></a>00116 <span class="comment">// Does it allow function declarator syntax? The following compilers are known to work:</span>
<a name="l00117"></a>00117 <span class="preprocessor">#if defined(FASTDLGT_ISMSVC) &amp;&amp; (_MSC_VER &gt;=1310) // VC 7.1</span>
<a name="l00118"></a>00118 <span class="preprocessor"></span><span class="preprocessor">#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX</span>
<a name="l00119"></a>00119 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00120"></a>00120 <span class="preprocessor"></span>
<a name="l00121"></a>00121 <span class="comment">// Gcc(2.95+), and versions of Digital Mars, Intel and Comeau in common use.</span>
<a name="l00122"></a>00122 <span class="preprocessor">#if defined (__DMC__) || defined(__GNUC__) || defined(__ICL) || defined(__COMO__)</span>
<a name="l00123"></a>00123 <span class="preprocessor"></span><span class="preprocessor">#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX</span>
<a name="l00124"></a>00124 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00125"></a>00125 <span class="preprocessor"></span>
<a name="l00126"></a>00126 <span class="comment">// It works on Metrowerks MWCC 3.2.2. From boost.Config it should work on earlier ones too.</span>
<a name="l00127"></a>00127 <span class="preprocessor">#if defined (__MWERKS__)</span>
<a name="l00128"></a>00128 <span class="preprocessor"></span><span class="preprocessor">#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX</span>
<a name="l00129"></a>00129 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00130"></a>00130 <span class="preprocessor"></span>
<a name="l00131"></a>00131 <span class="preprocessor">#ifdef __GNUC__ // Workaround GCC bug #8271 </span>
<a name="l00132"></a>00132 <span class="preprocessor"></span>    <span class="comment">// At present, GCC doesn&#39;t recognize constness of MFPs in templates</span>
<a name="l00133"></a>00133 <span class="preprocessor">#define FASTDELEGATE_GCC_BUG_8271</span>
<a name="l00134"></a>00134 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00135"></a>00135 <span class="preprocessor"></span>
<a name="l00136"></a>00136 
<a name="l00137"></a>00137 <span class="comment"></span>
<a name="l00138"></a>00138 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00139"></a>00139 <span class="comment"></span><span class="comment">//                      General tricks used in this code</span>
<a name="l00140"></a>00140 <span class="comment">//</span>
<a name="l00141"></a>00141 <span class="comment">// (a) Error messages are generated by typdefing an array of negative size to</span>
<a name="l00142"></a>00142 <span class="comment">//     generate compile-time errors.</span>
<a name="l00143"></a>00143 <span class="comment">// (b) Warning messages on MSVC are generated by declaring unused variables, and</span>
<a name="l00144"></a>00144 <span class="comment">//      enabling the &quot;variable XXX is never used&quot; warning.</span>
<a name="l00145"></a>00145 <span class="comment">// (c) Unions are used in a few compiler-specific cases to perform illegal casts.</span>
<a name="l00146"></a>00146 <span class="comment">// (d) For Microsoft and Intel, when adjusting the &#39;this&#39; pointer, it&#39;s cast to</span>
<a name="l00147"></a>00147 <span class="comment">//     (char *) first to ensure that the correct number of *bytes* are added.</span>
<a name="l00148"></a>00148 <span class="comment">//</span><span class="comment"></span>
<a name="l00149"></a>00149 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00150"></a>00150 <span class="comment"></span><span class="comment">//                      Helper templates</span>
<a name="l00151"></a>00151 <span class="comment">//</span><span class="comment"></span>
<a name="l00152"></a>00152 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00153"></a>00153 <span class="comment"></span><span class="comment"></span>
<a name="l00154"></a>00154 <span class="comment">/// @cond FASTDELEGATE</span>
<a name="l00155"></a>00155 <span class="comment"></span><span class="keyword">namespace </span>detail {  <span class="comment">// we&#39;ll hide the implementation details in a nested namespace.</span>
<a name="l00156"></a>00156 
<a name="l00157"></a>00157 <span class="comment">//      implicit_cast&lt; &gt;</span>
<a name="l00158"></a>00158 <span class="comment">// I believe this was originally going to be in the C++ standard but </span>
<a name="l00159"></a>00159 <span class="comment">// was left out by accident. It&#39;s even milder than static_cast.</span>
<a name="l00160"></a>00160 <span class="comment">// I use it instead of static_cast&lt;&gt; to emphasize that I&#39;m not doing</span>
<a name="l00161"></a>00161 <span class="comment">// anything nasty. </span>
<a name="l00162"></a>00162 <span class="comment">// Usage is identical to static_cast&lt;&gt;</span><span class="comment"></span>
<a name="l00163"></a>00163 <span class="comment">/**</span>
<a name="l00164"></a>00164 <span class="comment">    @note I added</span>
<a name="l00165"></a>00165 <span class="comment">*/</span>
<a name="l00166"></a>00166 <span class="keyword">template</span> &lt;<span class="keyword">class</span> OutputClass, <span class="keyword">class</span> InputClass&gt;
<a name="l00167"></a>00167 <span class="keyword">inline</span> OutputClass implicit_cast(InputClass input){
<a name="l00168"></a>00168     <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>OutputClass<span class="keyword">&gt;</span>(input); <span class="comment">// changed by Dan Larimer</span>
<a name="l00169"></a>00169     <span class="comment">//return input; // original line</span>
<a name="l00170"></a>00170 }
<a name="l00171"></a>00171 
<a name="l00172"></a>00172 <span class="comment">//      horrible_cast&lt; &gt;</span>
<a name="l00173"></a>00173 <span class="comment">// This is truly evil. It completely subverts C++&#39;s type system, allowing you </span>
<a name="l00174"></a>00174 <span class="comment">// to cast from any class to any other class. Technically, using a union </span>
<a name="l00175"></a>00175 <span class="comment">// to perform the cast is undefined behaviour (even in C). But we can see if</span>
<a name="l00176"></a>00176 <span class="comment">// it is OK by checking that the union is the same size as each of its members.</span>
<a name="l00177"></a>00177 <span class="comment">// horrible_cast&lt;&gt; should only be used for compiler-specific workarounds. </span>
<a name="l00178"></a>00178 <span class="comment">// Usage is identical to reinterpret_cast&lt;&gt;.</span>
<a name="l00179"></a>00179 
<a name="l00180"></a>00180 <span class="comment">// This union is declared outside the horrible_cast because BCC 5.5.1</span>
<a name="l00181"></a>00181 <span class="comment">// can&#39;t inline a function with a nested class, and gives a warning.</span>
<a name="l00182"></a>00182 <span class="keyword">template</span> &lt;<span class="keyword">class</span> OutputClass, <span class="keyword">class</span> InputClass&gt;
<a name="l00183"></a>00183 <span class="keyword">union </span>horrible_union{
<a name="l00184"></a>00184     OutputClass out;
<a name="l00185"></a>00185     InputClass in;
<a name="l00186"></a>00186 };
<a name="l00187"></a>00187 
<a name="l00188"></a>00188 <span class="keyword">template</span> &lt;<span class="keyword">class</span> OutputClass, <span class="keyword">class</span> InputClass&gt;
<a name="l00189"></a>00189 <span class="keyword">inline</span> OutputClass horrible_cast(<span class="keyword">const</span> InputClass input){
<a name="l00190"></a>00190     horrible_union&lt;OutputClass, InputClass&gt; u;
<a name="l00191"></a>00191     <span class="comment">// Cause a compile-time error if in, out and u are not the same size.</span>
<a name="l00192"></a>00192     <span class="comment">// If the compile fails here, it means the compiler has peculiar</span>
<a name="l00193"></a>00193     <span class="comment">// unions which would prevent the cast from working.</span>
<a name="l00194"></a>00194     <span class="keyword">typedef</span> <span class="keywordtype">int</span> ERROR_CantUseHorrible_cast[<span class="keyword">sizeof</span>(InputClass)==<span class="keyword">sizeof</span>(u) 
<a name="l00195"></a>00195         &amp;&amp; <span class="keyword">sizeof</span>(InputClass)==<span class="keyword">sizeof</span>(OutputClass) ? 1 : -1];
<a name="l00196"></a>00196     u.in = input;
<a name="l00197"></a>00197     <span class="keywordflow">return</span> u.out;
<a name="l00198"></a>00198 }
<a name="l00199"></a>00199 <span class="comment"></span>
<a name="l00200"></a>00200 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00201"></a>00201 <span class="comment"></span><span class="comment">//                      Workarounds</span>
<a name="l00202"></a>00202 <span class="comment">//</span><span class="comment"></span>
<a name="l00203"></a>00203 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00204"></a>00204 <span class="comment"></span>
<a name="l00205"></a>00205 <span class="comment">// Backwards compatibility: This macro used to be necessary in the virtual inheritance</span>
<a name="l00206"></a>00206 <span class="comment">// case for Intel and Microsoft. Now it just forward-declares the class.</span>
<a name="l00207"></a>00207 <span class="preprocessor">#define FASTDELEGATEDECLARE(CLASSNAME)  class CLASSNAME;</span>
<a name="l00208"></a>00208 <span class="preprocessor"></span>
<a name="l00209"></a>00209 <span class="comment">// Prevent use of the static function hack with the DOS medium model.</span>
<a name="l00210"></a>00210 <span class="preprocessor">#ifdef __MEDIUM__</span>
<a name="l00211"></a>00211 <span class="preprocessor"></span><span class="preprocessor">#undef FASTDELEGATE_USESTATICFUNCTIONHACK</span>
<a name="l00212"></a>00212 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00213"></a>00213 <span class="preprocessor"></span>
<a name="l00214"></a>00214 <span class="comment">//          DefaultVoid - a workaround for &#39;void&#39; templates in VC6.</span>
<a name="l00215"></a>00215 <span class="comment">//</span>
<a name="l00216"></a>00216 <span class="comment">//  (1) VC6 and earlier do not allow &#39;void&#39; as a default template argument.</span>
<a name="l00217"></a>00217 <span class="comment">//  (2) They also doesn&#39;t allow you to return &#39;void&#39; from a function.</span>
<a name="l00218"></a>00218 <span class="comment">//</span>
<a name="l00219"></a>00219 <span class="comment">// Workaround for (1): Declare a dummy type &#39;DefaultVoid&#39; which we use</span>
<a name="l00220"></a>00220 <span class="comment">//   when we&#39;d like to use &#39;void&#39;. We convert it into &#39;void&#39; and back</span>
<a name="l00221"></a>00221 <span class="comment">//   using the templates default_void_to_void&lt;&gt; and void_to_default_void&lt;&gt;.</span>
<a name="l00222"></a>00222 <span class="comment">// Workaround for (2): On VC6, the code for calling a void function is</span>
<a name="l00223"></a>00223 <span class="comment">//   identical to the code for calling a non-void function in which the</span>
<a name="l00224"></a>00224 <span class="comment">//   return value is never used, provided the return value is returned</span>
<a name="l00225"></a>00225 <span class="comment">//   in the EAX register, rather than on the stack. </span>
<a name="l00226"></a>00226 <span class="comment">//   This is true for most fundamental types such as int, enum, void *.</span>
<a name="l00227"></a>00227 <span class="comment">//   Const void * is the safest option since it doesn&#39;t participate </span>
<a name="l00228"></a>00228 <span class="comment">//   in any automatic conversions. But on a 16-bit compiler it might</span>
<a name="l00229"></a>00229 <span class="comment">//   cause extra code to be generated, so we disable it for all compilers</span>
<a name="l00230"></a>00230 <span class="comment">//   except for VC6 (and VC5).</span>
<a name="l00231"></a>00231 <span class="preprocessor">#ifdef FASTDLGT_VC6</span>
<a name="l00232"></a>00232 <span class="preprocessor"></span><span class="comment">// VC6 workaround</span>
<a name="l00233"></a>00233 <span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keywordtype">void</span> * DefaultVoid;
<a name="l00234"></a>00234 <span class="preprocessor">#else</span>
<a name="l00235"></a>00235 <span class="preprocessor"></span><span class="comment">// On any other compiler, just use a normal void.</span>
<a name="l00236"></a>00236 <span class="keyword">typedef</span> <span class="keywordtype">void</span> DefaultVoid;
<a name="l00237"></a>00237 <span class="preprocessor">#endif</span>
<a name="l00238"></a>00238 <span class="preprocessor"></span>
<a name="l00239"></a>00239 <span class="comment">// Translate from &#39;DefaultVoid&#39; to &#39;void&#39;.</span>
<a name="l00240"></a>00240 <span class="comment">// Everything else is unchanged</span>
<a name="l00241"></a>00241 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00242"></a>00242 <span class="keyword">struct </span>default_void_to_void { <span class="keyword">typedef</span> T type; };
<a name="l00243"></a>00243 
<a name="l00244"></a>00244 <span class="keyword">template</span> &lt;&gt;
<a name="l00245"></a>00245 <span class="keyword">struct </span>default_void_to_void&lt;DefaultVoid&gt; {  <span class="keyword">typedef</span> <span class="keywordtype">void</span> type; };
<a name="l00246"></a>00246 
<a name="l00247"></a>00247 <span class="comment">// Translate from &#39;void&#39; into &#39;DefaultVoid&#39;</span>
<a name="l00248"></a>00248 <span class="comment">// Everything else is unchanged</span>
<a name="l00249"></a>00249 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00250"></a>00250 <span class="keyword">struct </span>void_to_default_void { <span class="keyword">typedef</span> T type; };
<a name="l00251"></a>00251 
<a name="l00252"></a>00252 <span class="keyword">template</span> &lt;&gt;
<a name="l00253"></a>00253 <span class="keyword">struct </span>void_to_default_void&lt;void&gt; { <span class="keyword">typedef</span> DefaultVoid type; };
<a name="l00254"></a>00254 
<a name="l00255"></a>00255 
<a name="l00256"></a>00256 <span class="comment"></span>
<a name="l00257"></a>00257 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00258"></a>00258 <span class="comment"></span><span class="comment">//                      Fast Delegates, part 1:</span>
<a name="l00259"></a>00259 <span class="comment">//</span>
<a name="l00260"></a>00260 <span class="comment">//      Conversion of member function pointer to a standard form</span>
<a name="l00261"></a>00261 <span class="comment">//</span><span class="comment"></span>
<a name="l00262"></a>00262 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00263"></a>00263 <span class="comment"></span>
<a name="l00264"></a>00264 <span class="comment">// GenericClass is a fake class, ONLY used to provide a type.</span>
<a name="l00265"></a>00265 <span class="comment">// It is vitally important that it is never defined, so that the compiler doesn&#39;t</span>
<a name="l00266"></a>00266 <span class="comment">// think it can optimize the invocation. For example, Borland generates simpler</span>
<a name="l00267"></a>00267 <span class="comment">// code if it knows the class only uses single inheritance.</span>
<a name="l00268"></a>00268 
<a name="l00269"></a>00269 <span class="comment">// Compilers using Microsoft&#39;s structure need to be treated as a special case.</span>
<a name="l00270"></a>00270 <span class="preprocessor">#ifdef  FASTDLGT_MICROSOFT_MFP</span>
<a name="l00271"></a>00271 <span class="preprocessor"></span>
<a name="l00272"></a>00272 <span class="preprocessor">#ifdef FASTDLGT_HASINHERITANCE_KEYWORDS</span>
<a name="l00273"></a>00273 <span class="preprocessor"></span>    <span class="comment">// For Microsoft and Intel, we want to ensure that it&#39;s the most efficient type of MFP </span>
<a name="l00274"></a>00274     <span class="comment">// (4 bytes), even when the /vmg option is used. Declaring an empty class </span>
<a name="l00275"></a>00275     <span class="comment">// would give 16 byte pointers in this case....</span>
<a name="l00276"></a>00276     <span class="keyword">class </span>__single_inheritance GenericClass;
<a name="l00277"></a>00277 <span class="preprocessor">#endif</span>
<a name="l00278"></a>00278 <span class="preprocessor"></span>    <span class="comment">// ...but for Codeplay, an empty class *always* gives 4 byte pointers.</span>
<a name="l00279"></a>00279     <span class="comment">// If compiled with the /clr option (&quot;managed C++&quot;), the JIT compiler thinks</span>
<a name="l00280"></a>00280     <span class="comment">// it needs to load GenericClass before it can call any of its functions,</span>
<a name="l00281"></a>00281     <span class="comment">// (compiles OK but crashes at runtime!), so we need to declare an </span>
<a name="l00282"></a>00282     <span class="comment">// empty class to make it happy.</span>
<a name="l00283"></a>00283     <span class="comment">// Codeplay and VC4 can&#39;t cope with the unknown_inheritance case either.</span>
<a name="l00284"></a>00284     <span class="keyword">class </span>GenericClass {};
<a name="l00285"></a>00285 <span class="preprocessor">#else</span>
<a name="l00286"></a>00286 <span class="preprocessor"></span>    <span class="keyword">class </span>GenericClass {};
<a name="l00287"></a>00287 <span class="preprocessor">#endif</span>
<a name="l00288"></a>00288 <span class="preprocessor"></span>
<a name="l00289"></a>00289 <span class="comment">// The size of a single inheritance member function pointer.</span>
<a name="l00290"></a>00290 <span class="keyword">const</span> <span class="keywordtype">int</span> SINGLE_MEMFUNCPTR_SIZE = <span class="keyword">sizeof</span>(void (GenericClass::*)());
<a name="l00291"></a>00291 <span class="keyword">const</span> <span class="keywordtype">int</span> SINGLE_MEMDATA_SIZE = <span class="keyword">sizeof</span>(<span class="keywordtype">int</span> GenericClass::*);
<a name="l00292"></a>00292 
<a name="l00293"></a>00293 <span class="comment">//                      SimplifyMemFunc&lt; &gt;::Convert()</span>
<a name="l00294"></a>00294 <span class="comment">//</span>
<a name="l00295"></a>00295 <span class="comment">//  A template function that converts an arbitrary member function pointer into the </span>
<a name="l00296"></a>00296 <span class="comment">//  simplest possible form of member function pointer, using a supplied &#39;this&#39; pointer.</span>
<a name="l00297"></a>00297 <span class="comment">//  According to the standard, this can be done legally with reinterpret_cast&lt;&gt;.</span>
<a name="l00298"></a>00298 <span class="comment">//  For (non-standard) compilers which use member function pointers which vary in size </span>
<a name="l00299"></a>00299 <span class="comment">//  depending on the class, we need to use  knowledge of the internal structure of a </span>
<a name="l00300"></a>00300 <span class="comment">//  member function pointer, as used by the compiler. Template specialization is used</span>
<a name="l00301"></a>00301 <span class="comment">//  to distinguish between the sizes. Because some compilers don&#39;t support partial </span>
<a name="l00302"></a>00302 <span class="comment">//  template specialisation, I use full specialisation of a wrapper struct.</span>
<a name="l00303"></a>00303 
<a name="l00304"></a>00304 <span class="comment">// general case -- don&#39;t know how to convert it. Force a compile failure</span>
<a name="l00305"></a>00305 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N&gt;
<a name="l00306"></a>00306 <span class="keyword">struct </span>SimplifyMemFunc {
<a name="l00307"></a>00307     <span class="keyword">template</span> &lt;<span class="keyword">class</span> X, <span class="keyword">class</span> XFuncType, <span class="keyword">class</span> GenericMemFuncType&gt;
<a name="l00308"></a>00308     <span class="keyword">inline</span> <span class="keyword">static</span> GenericClass *Convert(X *pthis, XFuncType function_to_bind, 
<a name="l00309"></a>00309         GenericMemFuncType &amp;bound_func) { 
<a name="l00310"></a>00310         <span class="comment">// Unsupported member function type -- force a compile failure.</span>
<a name="l00311"></a>00311         <span class="comment">// (it&#39;s illegal to have a array with negative size).</span>
<a name="l00312"></a>00312         <span class="keyword">typedef</span> <span class="keywordtype">char</span> ERROR_Unsupported_member_function_pointer_on_this_compiler[N-100];
<a name="l00313"></a>00313         <span class="keywordflow">return</span> 0; 
<a name="l00314"></a>00314     }
<a name="l00315"></a>00315 };
<a name="l00316"></a>00316 
<a name="l00317"></a>00317 <span class="comment">// For compilers where all member func ptrs are the same size, everything goes here.</span>
<a name="l00318"></a>00318 <span class="comment">// For non-standard compilers, only single_inheritance classes go here.</span>
<a name="l00319"></a>00319 <span class="keyword">template</span> &lt;&gt;
<a name="l00320"></a>00320 <span class="keyword">struct </span>SimplifyMemFunc&lt;SINGLE_MEMFUNCPTR_SIZE&gt;  {   
<a name="l00321"></a>00321     <span class="keyword">template</span> &lt;<span class="keyword">class</span> X, <span class="keyword">class</span> XFuncType, <span class="keyword">class</span> GenericMemFuncType&gt;
<a name="l00322"></a>00322     <span class="keyword">inline</span> <span class="keyword">static</span> GenericClass *Convert(X *pthis, XFuncType function_to_bind, 
<a name="l00323"></a>00323             GenericMemFuncType &amp;bound_func) {
<a name="l00324"></a>00324 <span class="preprocessor">#if defined __DMC__  </span>
<a name="l00325"></a>00325 <span class="preprocessor"></span>        <span class="comment">// Digital Mars doesn&#39;t allow you to cast between abitrary PMF&#39;s, </span>
<a name="l00326"></a>00326         <span class="comment">// even though the standard says you can. The 32-bit compiler lets you</span>
<a name="l00327"></a>00327         <span class="comment">// static_cast through an int, but the DOS compiler doesn&#39;t.</span>
<a name="l00328"></a>00328         bound_func = horrible_cast&lt;GenericMemFuncType&gt;(function_to_bind);
<a name="l00329"></a>00329 <span class="preprocessor">#else </span>
<a name="l00330"></a>00330 <span class="preprocessor"></span>        bound_func = <span class="keyword">reinterpret_cast&lt;</span>GenericMemFuncType<span class="keyword">&gt;</span>(function_to_bind);
<a name="l00331"></a>00331 <span class="preprocessor">#endif</span>
<a name="l00332"></a>00332 <span class="preprocessor"></span>        <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>GenericClass *<span class="keyword">&gt;</span>(pthis);
<a name="l00333"></a>00333     }
<a name="l00334"></a>00334 };
<a name="l00335"></a>00335 <span class="comment"></span>
<a name="l00336"></a>00336 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00337"></a>00337 <span class="comment"></span><span class="comment">//                      Fast Delegates, part 1b:</span>
<a name="l00338"></a>00338 <span class="comment">//</span>
<a name="l00339"></a>00339 <span class="comment">//                  Workarounds for Microsoft and Intel</span>
<a name="l00340"></a>00340 <span class="comment">//</span><span class="comment"></span>
<a name="l00341"></a>00341 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00342"></a>00342 <span class="comment"></span>
<a name="l00343"></a>00343 
<a name="l00344"></a>00344 <span class="comment">// Compilers with member function pointers which violate the standard (MSVC, Intel, Codeplay),</span>
<a name="l00345"></a>00345 <span class="comment">// need to be treated as a special case.</span>
<a name="l00346"></a>00346 <span class="preprocessor">#ifdef FASTDLGT_MICROSOFT_MFP</span>
<a name="l00347"></a>00347 <span class="preprocessor"></span>
<a name="l00348"></a>00348 <span class="comment">// We use unions to perform horrible_casts. I would like to use #pragma pack(push, 1)</span>
<a name="l00349"></a>00349 <span class="comment">// at the start of each function for extra safety, but VC6 seems to ICE</span>
<a name="l00350"></a>00350 <span class="comment">// intermittently if you do this inside a template.</span>
<a name="l00351"></a>00351 
<a name="l00352"></a>00352 <span class="comment">// __multiple_inheritance classes go here</span>
<a name="l00353"></a>00353 <span class="comment">// Nasty hack for Microsoft and Intel (IA32 and Itanium)</span>
<a name="l00354"></a>00354 <span class="keyword">template</span>&lt;&gt;
<a name="l00355"></a>00355 <span class="keyword">struct </span>SimplifyMemFunc&lt; SINGLE_MEMFUNCPTR_SIZE + sizeof(int) &gt;  {
<a name="l00356"></a>00356     <span class="keyword">template</span> &lt;<span class="keyword">class</span> X, <span class="keyword">class</span> XFuncType, <span class="keyword">class</span> GenericMemFuncType&gt;
<a name="l00357"></a>00357     <span class="keyword">inline</span> <span class="keyword">static</span> GenericClass *Convert(X *pthis, XFuncType function_to_bind, 
<a name="l00358"></a>00358         GenericMemFuncType &amp;bound_func) { 
<a name="l00359"></a>00359         <span class="comment">// We need to use a horrible_cast to do this conversion.</span>
<a name="l00360"></a>00360         <span class="comment">// In MSVC, a multiple inheritance member pointer is internally defined as:</span>
<a name="l00361"></a>00361         <span class="keyword">union </span>{
<a name="l00362"></a>00362             XFuncType func;
<a name="l00363"></a>00363             <span class="keyword">struct </span>{     
<a name="l00364"></a>00364                 GenericMemFuncType funcaddress; <span class="comment">// points to the actual member function</span>
<a name="l00365"></a>00365                 <span class="keywordtype">int</span> delta;       <span class="comment">// #BYTES to be added to the &#39;this&#39; pointer</span>
<a name="l00366"></a>00366             }s;
<a name="l00367"></a>00367         } u;
<a name="l00368"></a>00368         <span class="comment">// Check that the horrible_cast will work</span>
<a name="l00369"></a>00369         <span class="keyword">typedef</span> <span class="keywordtype">int</span> ERROR_CantUsehorrible_cast[<span class="keyword">sizeof</span>(function_to_bind)==<span class="keyword">sizeof</span>(u.s)? 1 : -1];
<a name="l00370"></a>00370         u.func = function_to_bind;
<a name="l00371"></a>00371         bound_func = u.s.funcaddress;
<a name="l00372"></a>00372         <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>GenericClass *<span class="keyword">&gt;</span>(<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(pthis) + u.s.delta); 
<a name="l00373"></a>00373     }
<a name="l00374"></a>00374 };
<a name="l00375"></a>00375 
<a name="l00376"></a>00376 <span class="comment">// virtual inheritance is a real nuisance. It&#39;s inefficient and complicated.</span>
<a name="l00377"></a>00377 <span class="comment">// On MSVC and Intel, there isn&#39;t enough information in the pointer itself to</span>
<a name="l00378"></a>00378 <span class="comment">// enable conversion to a closure pointer. Earlier versions of this code didn&#39;t</span>
<a name="l00379"></a>00379 <span class="comment">// work for all cases, and generated a compile-time error instead.</span>
<a name="l00380"></a>00380 <span class="comment">// But a very clever hack invented by John M. Dlugosz solves this problem.</span>
<a name="l00381"></a>00381 <span class="comment">// My code is somewhat different to his: I have no asm code, and I make no </span>
<a name="l00382"></a>00382 <span class="comment">// assumptions about the calling convention that is used.</span>
<a name="l00383"></a>00383 
<a name="l00384"></a>00384 <span class="comment">// In VC++ and ICL, a virtual_inheritance member pointer </span>
<a name="l00385"></a>00385 <span class="comment">// is internally defined as:</span>
<a name="l00386"></a>00386 <span class="keyword">struct </span>MicrosoftVirtualMFP {
<a name="l00387"></a>00387     void (GenericClass::*codeptr)(); <span class="comment">// points to the actual member function</span>
<a name="l00388"></a>00388     <span class="keywordtype">int</span> delta;      <span class="comment">// #bytes to be added to the &#39;this&#39; pointer</span>
<a name="l00389"></a>00389     <span class="keywordtype">int</span> vtable_index; <span class="comment">// or 0 if no virtual inheritance</span>
<a name="l00390"></a>00390 };
<a name="l00391"></a>00391 <span class="comment">// The CRUCIAL feature of Microsoft/Intel MFPs which we exploit is that the</span>
<a name="l00392"></a>00392 <span class="comment">// m_codeptr member is *always* called, regardless of the values of the other</span>
<a name="l00393"></a>00393 <span class="comment">// members. (This is *not* true for other compilers, eg GCC, which obtain the</span>
<a name="l00394"></a>00394 <span class="comment">// function address from the vtable if a virtual function is being called).</span>
<a name="l00395"></a>00395 <span class="comment">// Dlugosz&#39;s trick is to make the codeptr point to a probe function which</span>
<a name="l00396"></a>00396 <span class="comment">// returns the &#39;this&#39; pointer that was used.</span>
<a name="l00397"></a>00397 
<a name="l00398"></a>00398 <span class="comment">// Define a generic class that uses virtual inheritance.</span>
<a name="l00399"></a>00399 <span class="comment">// It has a trival member function that returns the value of the &#39;this&#39; pointer.</span>
<a name="l00400"></a>00400 <span class="keyword">struct </span>GenericVirtualClass : <span class="keyword">virtual</span> <span class="keyword">public</span> GenericClass
<a name="l00401"></a>00401 {
<a name="l00402"></a>00402     <span class="keyword">typedef</span> GenericVirtualClass * (GenericVirtualClass::*ProbePtrType)();
<a name="l00403"></a>00403     GenericVirtualClass * GetThis() { <span class="keywordflow">return</span> <span class="keyword">this</span>; }
<a name="l00404"></a>00404 };
<a name="l00405"></a>00405 
<a name="l00406"></a>00406 <span class="comment">// __virtual_inheritance classes go here</span>
<a name="l00407"></a>00407 <span class="keyword">template</span> &lt;&gt;
<a name="l00408"></a>00408 <span class="keyword">struct </span>SimplifyMemFunc&lt;SINGLE_MEMFUNCPTR_SIZE + 2*<span class="keyword">sizeof</span>(int) &gt;
<a name="l00409"></a>00409 {
<a name="l00410"></a>00410 
<a name="l00411"></a>00411     <span class="keyword">template</span> &lt;<span class="keyword">class</span> X, <span class="keyword">class</span> XFuncType, <span class="keyword">class</span> GenericMemFuncType&gt;
<a name="l00412"></a>00412     <span class="keyword">inline</span> <span class="keyword">static</span> GenericClass *Convert(X *pthis, XFuncType function_to_bind, 
<a name="l00413"></a>00413         GenericMemFuncType &amp;bound_func) {
<a name="l00414"></a>00414         <span class="keyword">union </span>{
<a name="l00415"></a>00415             XFuncType func;
<a name="l00416"></a>00416             GenericClass* (X::*ProbeFunc)();
<a name="l00417"></a>00417             MicrosoftVirtualMFP s;
<a name="l00418"></a>00418         } u;
<a name="l00419"></a>00419         u.func = function_to_bind;
<a name="l00420"></a>00420         bound_func = <span class="keyword">reinterpret_cast&lt;</span>GenericMemFuncType<span class="keyword">&gt;</span>(u.s.codeptr);
<a name="l00421"></a>00421         <span class="keyword">union </span>{
<a name="l00422"></a>00422             GenericVirtualClass::ProbePtrType virtfunc;
<a name="l00423"></a>00423             MicrosoftVirtualMFP s;
<a name="l00424"></a>00424         } u2;
<a name="l00425"></a>00425         <span class="comment">// Check that the horrible_cast&lt;&gt;s will work</span>
<a name="l00426"></a>00426         <span class="keyword">typedef</span> <span class="keywordtype">int</span> ERROR_CantUsehorrible_cast[<span class="keyword">sizeof</span>(function_to_bind)==<span class="keyword">sizeof</span>(u.s)
<a name="l00427"></a>00427             &amp;&amp; <span class="keyword">sizeof</span>(function_to_bind)==<span class="keyword">sizeof</span>(u.ProbeFunc)
<a name="l00428"></a>00428             &amp;&amp; <span class="keyword">sizeof</span>(u2.virtfunc)==<span class="keyword">sizeof</span>(u2.s) ? 1 : -1];
<a name="l00429"></a>00429    <span class="comment">// Unfortunately, taking the address of a MF prevents it from being inlined, so </span>
<a name="l00430"></a>00430    <span class="comment">// this next line can&#39;t be completely optimised away by the compiler.</span>
<a name="l00431"></a>00431         u2.virtfunc = &amp;GenericVirtualClass::GetThis;
<a name="l00432"></a>00432         u.s.codeptr = u2.s.codeptr;
<a name="l00433"></a>00433         <span class="keywordflow">return</span> (pthis-&gt;*u.ProbeFunc)();
<a name="l00434"></a>00434     }
<a name="l00435"></a>00435 };
<a name="l00436"></a>00436 
<a name="l00437"></a>00437 <span class="preprocessor">#if (_MSC_VER &lt;1300)</span>
<a name="l00438"></a>00438 <span class="preprocessor"></span>
<a name="l00439"></a>00439 <span class="comment">// Nasty hack for Microsoft Visual C++ 6.0</span>
<a name="l00440"></a>00440 <span class="comment">// unknown_inheritance classes go here</span>
<a name="l00441"></a>00441 <span class="comment">// There is a compiler bug in MSVC6 which generates incorrect code in this case!!</span>
<a name="l00442"></a>00442 <span class="keyword">template</span> &lt;&gt;
<a name="l00443"></a>00443 <span class="keyword">struct </span>SimplifyMemFunc&lt;SINGLE_MEMFUNCPTR_SIZE + 3*<span class="keyword">sizeof</span>(int) &gt;
<a name="l00444"></a>00444 {
<a name="l00445"></a>00445     <span class="keyword">template</span> &lt;<span class="keyword">class</span> X, <span class="keyword">class</span> XFuncType, <span class="keyword">class</span> GenericMemFuncType&gt;
<a name="l00446"></a>00446     <span class="keyword">inline</span> <span class="keyword">static</span> GenericClass *Convert(X *pthis, XFuncType function_to_bind, 
<a name="l00447"></a>00447         GenericMemFuncType &amp;bound_func) {
<a name="l00448"></a>00448         <span class="comment">// There is an apalling but obscure compiler bug in MSVC6 and earlier:</span>
<a name="l00449"></a>00449         <span class="comment">// vtable_index and &#39;vtordisp&#39; are always set to 0 in the </span>
<a name="l00450"></a>00450         <span class="comment">// unknown_inheritance case!</span>
<a name="l00451"></a>00451         <span class="comment">// This means that an incorrect function could be called!!!</span>
<a name="l00452"></a>00452         <span class="comment">// Compiling with the /vmg option leads to potentially incorrect code.</span>
<a name="l00453"></a>00453         <span class="comment">// This is probably the reason that the IDE has a user interface for specifying</span>
<a name="l00454"></a>00454         <span class="comment">// the /vmg option, but it is disabled -  you can only specify /vmg on </span>
<a name="l00455"></a>00455         <span class="comment">// the command line. In VC1.5 and earlier, the compiler would ICE if it ever</span>
<a name="l00456"></a>00456         <span class="comment">// encountered this situation.</span>
<a name="l00457"></a>00457         <span class="comment">// It is OK to use the /vmg option if /vmm or /vms is specified.</span>
<a name="l00458"></a>00458 
<a name="l00459"></a>00459         <span class="comment">// Fortunately, the wrong function is only called in very obscure cases.</span>
<a name="l00460"></a>00460         <span class="comment">// It only occurs when a derived class overrides a virtual function declared </span>
<a name="l00461"></a>00461         <span class="comment">// in a virtual base class, and the member function </span>
<a name="l00462"></a>00462         <span class="comment">// points to the *Derived* version of that function. The problem can be</span>
<a name="l00463"></a>00463         <span class="comment">// completely averted in 100% of cases by using the *Base class* for the </span>
<a name="l00464"></a>00464         <span class="comment">// member fpointer. Ie, if you use the base class as an interface, you&#39;ll</span>
<a name="l00465"></a>00465         <span class="comment">// stay out of trouble.</span>
<a name="l00466"></a>00466         <span class="comment">// Occasionally, you might want to point directly to a derived class function</span>
<a name="l00467"></a>00467         <span class="comment">// that isn&#39;t an override of a base class. In this case, both vtable_index </span>
<a name="l00468"></a>00468         <span class="comment">// and &#39;vtordisp&#39; are zero, but a virtual_inheritance pointer will be generated.</span>
<a name="l00469"></a>00469         <span class="comment">// We can generate correct code in this case. To prevent an incorrect call from</span>
<a name="l00470"></a>00470         <span class="comment">// ever being made, on MSVC6 we generate a warning, and call a function to </span>
<a name="l00471"></a>00471         <span class="comment">// make the program crash instantly. </span>
<a name="l00472"></a>00472         <span class="keyword">typedef</span> <span class="keywordtype">char</span> ERROR_VC6CompilerBug[-100];
<a name="l00473"></a>00473         <span class="keywordflow">return</span> 0; 
<a name="l00474"></a>00474     }
<a name="l00475"></a>00475 };
<a name="l00476"></a>00476 
<a name="l00477"></a>00477 
<a name="l00478"></a>00478 <span class="preprocessor">#else </span>
<a name="l00479"></a>00479 <span class="preprocessor"></span>
<a name="l00480"></a>00480 <span class="comment">// Nasty hack for Microsoft and Intel (IA32 and Itanium)</span>
<a name="l00481"></a>00481 <span class="comment">// unknown_inheritance classes go here </span>
<a name="l00482"></a>00482 <span class="comment">// This is probably the ugliest bit of code I&#39;ve ever written. Look at the casts!</span>
<a name="l00483"></a>00483 <span class="comment">// There is a compiler bug in MSVC6 which prevents it from using this code.</span>
<a name="l00484"></a>00484 <span class="keyword">template</span> &lt;&gt;
<a name="l00485"></a>00485 <span class="keyword">struct </span>SimplifyMemFunc&lt;SINGLE_MEMFUNCPTR_SIZE + 3*<span class="keyword">sizeof</span>(int) &gt;
<a name="l00486"></a>00486 {
<a name="l00487"></a>00487     <span class="keyword">template</span> &lt;<span class="keyword">class</span> X, <span class="keyword">class</span> XFuncType, <span class="keyword">class</span> GenericMemFuncType&gt;
<a name="l00488"></a>00488     <span class="keyword">inline</span> <span class="keyword">static</span> GenericClass *Convert(X *pthis, XFuncType function_to_bind, 
<a name="l00489"></a>00489             GenericMemFuncType &amp;bound_func) {
<a name="l00490"></a>00490         <span class="comment">// The member function pointer is 16 bytes long. We can&#39;t use a normal cast, but</span>
<a name="l00491"></a>00491         <span class="comment">// we can use a union to do the conversion.</span>
<a name="l00492"></a>00492         <span class="keyword">union </span>{
<a name="l00493"></a>00493             XFuncType func;
<a name="l00494"></a>00494             <span class="comment">// In VC++ and ICL, an unknown_inheritance member pointer </span>
<a name="l00495"></a>00495             <span class="comment">// is internally defined as:</span>
<a name="l00496"></a>00496             <span class="keyword">struct </span>{
<a name="l00497"></a>00497                 GenericMemFuncType m_funcaddress; <span class="comment">// points to the actual member function</span>
<a name="l00498"></a>00498                 <span class="keywordtype">int</span> delta;      <span class="comment">// #bytes to be added to the &#39;this&#39; pointer</span>
<a name="l00499"></a>00499                 <span class="keywordtype">int</span> vtordisp;       <span class="comment">// #bytes to add to &#39;this&#39; to find the vtable</span>
<a name="l00500"></a>00500                 <span class="keywordtype">int</span> vtable_index; <span class="comment">// or 0 if no virtual inheritance</span>
<a name="l00501"></a>00501             } s;
<a name="l00502"></a>00502         } u;
<a name="l00503"></a>00503         <span class="comment">// Check that the horrible_cast will work</span>
<a name="l00504"></a>00504         <span class="keyword">typedef</span> <span class="keywordtype">int</span> ERROR_CantUsehorrible_cast[<span class="keyword">sizeof</span>(XFuncType)==<span class="keyword">sizeof</span>(u.s)? 1 : -1];
<a name="l00505"></a>00505         u.func = function_to_bind;
<a name="l00506"></a>00506         bound_func = u.s.funcaddress;
<a name="l00507"></a>00507         <span class="keywordtype">int</span> virtual_delta = 0;
<a name="l00508"></a>00508         <span class="keywordflow">if</span> (u.s.vtable_index) { <span class="comment">// Virtual inheritance is used</span>
<a name="l00509"></a>00509             <span class="comment">// First, get to the vtable. </span>
<a name="l00510"></a>00510             <span class="comment">// It is &#39;vtordisp&#39; bytes from the start of the class.</span>
<a name="l00511"></a>00511             <span class="keyword">const</span> <span class="keywordtype">int</span> * vtable = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">int</span> *const*<span class="keyword">&gt;</span>(
<a name="l00512"></a>00512                 <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(pthis) + u.s.vtordisp );
<a name="l00513"></a>00513 
<a name="l00514"></a>00514             <span class="comment">// &#39;vtable_index&#39; tells us where in the table we should be looking.</span>
<a name="l00515"></a>00515             virtual_delta = u.s.vtordisp + *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">int</span> *<span class="keyword">&gt;</span>( 
<a name="l00516"></a>00516                 <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(vtable) + u.s.vtable_index);
<a name="l00517"></a>00517         }
<a name="l00518"></a>00518         <span class="comment">// The int at &#39;virtual_delta&#39; gives us the amount to add to &#39;this&#39;.</span>
<a name="l00519"></a>00519         <span class="comment">// Finally we can add the three components together. Phew!</span>
<a name="l00520"></a>00520         <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>GenericClass *<span class="keyword">&gt;</span>(
<a name="l00521"></a>00521             <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(pthis) + u.s.delta + virtual_delta);
<a name="l00522"></a>00522     };
<a name="l00523"></a>00523 };
<a name="l00524"></a>00524 <span class="preprocessor">#endif // MSVC 7 and greater</span>
<a name="l00525"></a>00525 <span class="preprocessor"></span>
<a name="l00526"></a>00526 <span class="preprocessor">#endif // MS/Intel hacks</span>
<a name="l00527"></a>00527 <span class="preprocessor"></span>
<a name="l00528"></a>00528 }  <span class="comment">// namespace detail</span>
<a name="l00529"></a>00529 
<a name="l00530"></a>00530 <span class="comment"></span>
<a name="l00531"></a>00531 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00532"></a>00532 <span class="comment"></span><span class="comment">//                      Fast Delegates, part 2:</span>
<a name="l00533"></a>00533 <span class="comment">//</span>
<a name="l00534"></a>00534 <span class="comment">//  Define the delegate storage, and cope with static functions</span>
<a name="l00535"></a>00535 <span class="comment">//</span><span class="comment"></span>
<a name="l00536"></a>00536 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00537"></a>00537 <span class="comment"></span>
<a name="l00538"></a>00538 <span class="comment">// delegate_memento -- an opaque structure which can hold an arbitary delegate.</span>
<a name="l00539"></a>00539 <span class="comment">// It knows nothing about the calling convention or number of arguments used by</span>
<a name="l00540"></a>00540 <span class="comment">// the function pointed to.</span>
<a name="l00541"></a>00541 <span class="comment">// It supplies comparison operators so that it can be stored in STL collections.</span>
<a name="l00542"></a>00542 <span class="comment">// It cannot be set to anything other than null, nor invoked directly: </span>
<a name="l00543"></a>00543 <span class="comment">//   it must be converted to a specific delegate.</span>
<a name="l00544"></a>00544 
<a name="l00545"></a>00545 <span class="comment">// Implementation:</span>
<a name="l00546"></a>00546 <span class="comment">// There are two possible implementations: the Safe method and the Evil method.</span>
<a name="l00547"></a>00547 <span class="comment">//              delegate_memento - Safe version</span>
<a name="l00548"></a>00548 <span class="comment">//</span>
<a name="l00549"></a>00549 <span class="comment">// This implementation is standard-compliant, but a bit tricky.</span>
<a name="l00550"></a>00550 <span class="comment">// A static function pointer is stored inside the class. </span>
<a name="l00551"></a>00551 <span class="comment">// Here are the valid values:</span>
<a name="l00552"></a>00552 <span class="comment">// +-- Static pointer --+--pThis --+-- pMemFunc-+-- Meaning------+</span>
<a name="l00553"></a>00553 <span class="comment">// |   0                |  0       |   0        | Empty          |</span>
<a name="l00554"></a>00554 <span class="comment">// |   !=0              |(dontcare)|  Invoker   | Static function|</span>
<a name="l00555"></a>00555 <span class="comment">// |   0                |  !=0     |  !=0*      | Method call    |</span>
<a name="l00556"></a>00556 <span class="comment">// +--------------------+----------+------------+----------------+</span>
<a name="l00557"></a>00557 <span class="comment">//  * For Metrowerks, this can be 0. (first virtual function in a </span>
<a name="l00558"></a>00558 <span class="comment">//       single_inheritance class).</span>
<a name="l00559"></a>00559 <span class="comment">// When stored stored inside a specific delegate, the &#39;dontcare&#39; entries are replaced</span>
<a name="l00560"></a>00560 <span class="comment">// with a reference to the delegate itself. This complicates the = and == operators</span>
<a name="l00561"></a>00561 <span class="comment">// for the delegate class.</span>
<a name="l00562"></a>00562 
<a name="l00563"></a>00563 <span class="comment">//              delegate_memento - Evil version</span>
<a name="l00564"></a>00564 <span class="comment">//</span>
<a name="l00565"></a>00565 <span class="comment">// For compilers where data pointers are at least as big as code pointers, it is </span>
<a name="l00566"></a>00566 <span class="comment">// possible to store the function pointer in the this pointer, using another </span>
<a name="l00567"></a>00567 <span class="comment">// horrible_cast. In this case the delegate_memento implementation is simple:</span>
<a name="l00568"></a>00568 <span class="comment">// +--pThis --+-- pMemFunc-+-- Meaning---------------------+</span>
<a name="l00569"></a>00569 <span class="comment">// |    0     |  0         | Empty                         |</span>
<a name="l00570"></a>00570 <span class="comment">// |  !=0     |  !=0*      | Static function or method call|</span>
<a name="l00571"></a>00571 <span class="comment">// +----------+------------+-------------------------------+</span>
<a name="l00572"></a>00572 <span class="comment">//  * For Metrowerks, this can be 0. (first virtual function in a </span>
<a name="l00573"></a>00573 <span class="comment">//       single_inheritance class).</span>
<a name="l00574"></a>00574 <span class="comment">// Note that the Sun C++ and MSVC documentation explicitly state that they </span>
<a name="l00575"></a>00575 <span class="comment">// support static_cast between void * and function pointers.</span>
<a name="l00576"></a>00576 
<a name="l00577"></a>00577 <span class="keyword">class </span>delegate_memento {
<a name="l00578"></a>00578 <span class="keyword">protected</span>: 
<a name="l00579"></a>00579     <span class="comment">// the data is protected, not private, because many</span>
<a name="l00580"></a>00580     <span class="comment">// compilers have problems with template friends.</span>
<a name="l00581"></a>00581     <span class="keyword">typedef</span> void (detail::GenericClass::*GenericMemFuncType)(); <span class="comment">// arbitrary MFP.</span>
<a name="l00582"></a>00582     GenericMemFuncType m_pFunction;
<a name="l00583"></a>00583     detail::GenericClass *m_pthis;
<a name="l00584"></a>00584 
<a name="l00585"></a>00585 <span class="preprocessor">#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)</span>
<a name="l00586"></a>00586 <span class="preprocessor"></span>    <span class="keyword">typedef</span> void (*GenericFuncPtr)(); <span class="comment">// arbitrary code pointer</span>
<a name="l00587"></a>00587     GenericFuncPtr m_pStaticFunction;
<a name="l00588"></a>00588 <span class="preprocessor">#endif</span>
<a name="l00589"></a>00589 <span class="preprocessor"></span>
<a name="l00590"></a>00590 <span class="keyword">public</span>:
<a name="l00591"></a>00591 <span class="preprocessor">#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)</span>
<a name="l00592"></a>00592 <span class="preprocessor"></span>    delegate_memento() : m_pthis(0), m_pFunction(0), m_pStaticFunction(0) {};
<a name="l00593"></a>00593     <span class="keywordtype">void</span> clear() {
<a name="l00594"></a>00594         m_pthis=0; m_pFunction=0; m_pStaticFunction=0;
<a name="l00595"></a>00595     }
<a name="l00596"></a>00596 <span class="preprocessor">#else</span>
<a name="l00597"></a>00597 <span class="preprocessor"></span>    delegate_memento() : m_pFunction(0), m_pthis(0) {};
<a name="l00598"></a>00598     <span class="keywordtype">void</span> clear() {  m_pthis=0; m_pFunction=0;   }
<a name="l00599"></a>00599 <span class="preprocessor">#endif</span>
<a name="l00600"></a>00600 <span class="preprocessor"></span><span class="keyword">public</span>:
<a name="l00601"></a>00601 <span class="preprocessor">#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)</span>
<a name="l00602"></a>00602 <span class="preprocessor"></span>    <span class="keyword">inline</span> <span class="keywordtype">bool</span> IsEqual (<span class="keyword">const</span> delegate_memento &amp;x)<span class="keyword"> const</span>{
<a name="l00603"></a>00603         <span class="comment">// We have to cope with the static function pointers as a special case</span>
<a name="l00604"></a>00604         <span class="keywordflow">if</span> (m_pFunction!=x.m_pFunction) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00605"></a>00605         <span class="comment">// the static function ptrs must either both be equal, or both be 0.</span>
<a name="l00606"></a>00606         <span class="keywordflow">if</span> (m_pStaticFunction!=x.m_pStaticFunction) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00607"></a>00607         <span class="keywordflow">if</span> (m_pStaticFunction!=0) <span class="keywordflow">return</span> m_pthis==x.m_pthis;
<a name="l00608"></a>00608         <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00609"></a>00609     }
<a name="l00610"></a>00610 <span class="preprocessor">#else // Evil Method</span>
<a name="l00611"></a>00611 <span class="preprocessor"></span>    <span class="keyword">inline</span> <span class="keywordtype">bool</span> IsEqual (<span class="keyword">const</span> delegate_memento &amp;x)<span class="keyword"> const</span>{
<a name="l00612"></a>00612         <span class="keywordflow">return</span> m_pthis==x.m_pthis &amp;&amp; m_pFunction==x.m_pFunction;
<a name="l00613"></a>00613     }
<a name="l00614"></a>00614 <span class="preprocessor">#endif</span>
<a name="l00615"></a>00615 <span class="preprocessor"></span>    <span class="comment">// Provide a strict weak ordering for delegate_mementos.</span>
<a name="l00616"></a>00616     <span class="keyword">inline</span> <span class="keywordtype">bool</span> IsLess(<span class="keyword">const</span> delegate_memento &amp;right)<span class="keyword"> const </span>{
<a name="l00617"></a>00617         <span class="comment">// deal with static function pointers first</span>
<a name="l00618"></a>00618 <span class="preprocessor">#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)</span>
<a name="l00619"></a>00619 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (m_pStaticFunction !=0 || right.m_pStaticFunction!=0) 
<a name="l00620"></a>00620                 <span class="keywordflow">return</span> m_pStaticFunction &lt; right.m_pStaticFunction;
<a name="l00621"></a>00621 <span class="preprocessor">#endif</span>
<a name="l00622"></a>00622 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (m_pthis !=right.m_pthis) <span class="keywordflow">return</span> m_pthis &lt; right.m_pthis;
<a name="l00623"></a>00623     <span class="comment">// There are no ordering operators for member function pointers, </span>
<a name="l00624"></a>00624     <span class="comment">// but we can fake one by comparing each byte. The resulting ordering is</span>
<a name="l00625"></a>00625     <span class="comment">// arbitrary (and compiler-dependent), but it permits storage in ordered STL containers.</span>
<a name="l00626"></a>00626         <span class="keywordflow">return</span> memcmp(&amp;m_pFunction, &amp;right.m_pFunction, <span class="keyword">sizeof</span>(m_pFunction)) &lt; 0;
<a name="l00627"></a>00627 
<a name="l00628"></a>00628     }
<a name="l00629"></a>00629     <span class="comment">// BUGFIX (Mar 2005):</span>
<a name="l00630"></a>00630     <span class="comment">// We can&#39;t just compare m_pFunction because on Metrowerks,</span>
<a name="l00631"></a>00631     <span class="comment">// m_pFunction can be zero even if the delegate is not empty!</span>
<a name="l00632"></a>00632     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator ! () const     <span class="comment">// Is it bound to anything?</span>
<a name="l00633"></a>00633     { <span class="keywordflow">return</span> m_pthis==0 &amp;&amp; m_pFunction==0; }
<a name="l00634"></a>00634     <span class="keyword">inline</span> <span class="keywordtype">bool</span> empty() const       <span class="comment">// Is it bound to anything?</span>
<a name="l00635"></a>00635     { <span class="keywordflow">return</span> m_pthis==0 &amp;&amp; m_pFunction==0; }
<a name="l00636"></a>00636 <span class="keyword">public</span>:
<a name="l00637"></a>00637     delegate_memento &amp; operator = (<span class="keyword">const</span> delegate_memento &amp;right)  {
<a name="l00638"></a>00638         set_mementoFrom(right); 
<a name="l00639"></a>00639         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00640"></a>00640     }
<a name="l00641"></a>00641     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &lt;(<span class="keyword">const</span> delegate_memento &amp;right) {
<a name="l00642"></a>00642         <span class="keywordflow">return</span> IsLess(right);
<a name="l00643"></a>00643     }
<a name="l00644"></a>00644     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &gt;(<span class="keyword">const</span> delegate_memento &amp;right) {
<a name="l00645"></a>00645         <span class="keywordflow">return</span> right.IsLess(*<span class="keyword">this</span>);
<a name="l00646"></a>00646     }
<a name="l00647"></a>00647     delegate_memento (<span class="keyword">const</span> delegate_memento &amp;right)  : 
<a name="l00648"></a>00648         m_pFunction(right.m_pFunction), m_pthis(right.m_pthis)
<a name="l00649"></a>00649 #if !defined(<a class="code" href="fast__delegate_8hpp.html#a32543cbcde64e264172b05087b344432">FASTDELEGATE_USESTATICFUNCTIONHACK</a>)
<a name="l00650"></a>00650         , m_pStaticFunction (right.m_pStaticFunction)
<a name="l00651"></a>00651 #endif
<a name="l00652"></a>00652         {}
<a name="l00653"></a>00653 <span class="keyword">protected</span>:
<a name="l00654"></a>00654     <span class="keywordtype">void</span> set_mementoFrom(<span class="keyword">const</span> delegate_memento &amp;right)  {
<a name="l00655"></a>00655         m_pFunction = right.m_pFunction;
<a name="l00656"></a>00656         m_pthis = right.m_pthis;
<a name="l00657"></a>00657 <span class="preprocessor">#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)</span>
<a name="l00658"></a>00658 <span class="preprocessor"></span>        m_pStaticFunction = right.m_pStaticFunction;
<a name="l00659"></a>00659 <span class="preprocessor">#endif</span>
<a name="l00660"></a>00660 <span class="preprocessor"></span>    }
<a name="l00661"></a>00661 };
<a name="l00662"></a>00662 
<a name="l00663"></a>00663 
<a name="l00664"></a>00664 <span class="comment">//                      ClosurePtr&lt;&gt;</span>
<a name="l00665"></a>00665 <span class="comment">//</span>
<a name="l00666"></a>00666 <span class="comment">// A private wrapper class that adds function signatures to delegate_memento.</span>
<a name="l00667"></a>00667 <span class="comment">// It&#39;s the class that does most of the actual work.</span>
<a name="l00668"></a>00668 <span class="comment">// The signatures are specified by:</span>
<a name="l00669"></a>00669 <span class="comment">// GenericMemFunc: must be a type of GenericClass member function pointer. </span>
<a name="l00670"></a>00670 <span class="comment">// StaticFuncPtr:  must be a type of function pointer with the same signature </span>
<a name="l00671"></a>00671 <span class="comment">//                 as GenericMemFunc.</span>
<a name="l00672"></a>00672 <span class="comment">// UnvoidStaticFuncPtr: is the same as StaticFuncPtr, except on VC6</span>
<a name="l00673"></a>00673 <span class="comment">//                 where it never returns void (returns DefaultVoid instead).</span>
<a name="l00674"></a>00674 
<a name="l00675"></a>00675 <span class="comment">// An outer class, fast_delegateN&lt;&gt;, handles the invoking and creates the</span>
<a name="l00676"></a>00676 <span class="comment">// necessary typedefs.</span>
<a name="l00677"></a>00677 <span class="comment">// This class does everything else.</span>
<a name="l00678"></a>00678 
<a name="l00679"></a>00679 <span class="keyword">namespace </span>detail {
<a name="l00680"></a>00680 
<a name="l00681"></a>00681 <span class="keyword">template</span> &lt; <span class="keyword">class</span> GenericMemFunc, <span class="keyword">class</span> StaticFuncPtr, <span class="keyword">class</span> Un<span class="keywordtype">void</span>StaticFuncPtr&gt;
<a name="l00682"></a>00682 <span class="keyword">class </span>ClosurePtr : <span class="keyword">public</span> delegate_memento {
<a name="l00683"></a>00683 <span class="keyword">public</span>:
<a name="l00684"></a>00684     <span class="comment">// These functions are for setting the delegate to a member function.</span>
<a name="l00685"></a>00685 
<a name="l00686"></a>00686     <span class="comment">// Here&#39;s the clever bit: we convert an arbitrary member function into a </span>
<a name="l00687"></a>00687     <span class="comment">// standard form. XMemFunc should be a member function of class X, but I can&#39;t </span>
<a name="l00688"></a>00688     <span class="comment">// enforce that here. It needs to be enforced by the wrapper class.</span>
<a name="l00689"></a>00689     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> XMemFunc &gt;
<a name="l00690"></a>00690     <span class="keyword">inline</span> <span class="keywordtype">void</span> bindmemfunc(X *pthis, XMemFunc function_to_bind ) {
<a name="l00691"></a>00691         m_pthis = SimplifyMemFunc&lt; sizeof(function_to_bind) &gt;
<a name="l00692"></a>00692             ::Convert(pthis, function_to_bind, m_pFunction);
<a name="l00693"></a>00693 <span class="preprocessor">#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)</span>
<a name="l00694"></a>00694 <span class="preprocessor"></span>        m_pStaticFunction = 0;
<a name="l00695"></a>00695 <span class="preprocessor">#endif</span>
<a name="l00696"></a>00696 <span class="preprocessor"></span>    }
<a name="l00697"></a>00697     <span class="comment">// For const member functions, we only need a const class pointer.</span>
<a name="l00698"></a>00698     <span class="comment">// Since we know that the member function is const, it&#39;s safe to </span>
<a name="l00699"></a>00699     <span class="comment">// remove the const qualifier from the &#39;this&#39; pointer with a const_cast.</span>
<a name="l00700"></a>00700     <span class="comment">// VC6 has problems if we just overload &#39;bindmemfunc&#39;, so we give it a different name.</span>
<a name="l00701"></a>00701     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> XMemFunc&gt;
<a name="l00702"></a>00702     <span class="keyword">inline</span> <span class="keywordtype">void</span> bindconstmemfunc(<span class="keyword">const</span> X *pthis, XMemFunc function_to_bind) {
<a name="l00703"></a>00703         m_pthis= SimplifyMemFunc&lt; sizeof(function_to_bind) &gt;
<a name="l00704"></a>00704             ::Convert(<span class="keyword">const_cast&lt;</span>X*<span class="keyword">&gt;</span>(pthis), function_to_bind, m_pFunction);
<a name="l00705"></a>00705 <span class="preprocessor">#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)</span>
<a name="l00706"></a>00706 <span class="preprocessor"></span>        m_pStaticFunction = 0;
<a name="l00707"></a>00707 <span class="preprocessor">#endif</span>
<a name="l00708"></a>00708 <span class="preprocessor"></span>    }
<a name="l00709"></a>00709 <span class="preprocessor">#ifdef FASTDELEGATE_GCC_BUG_8271    // At present, GCC doesn&#39;t recognize constness of MFPs in templates</span>
<a name="l00710"></a>00710 <span class="preprocessor"></span>    <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> XMemFunc&gt;
<a name="l00711"></a>00711     <span class="keyword">inline</span> <span class="keywordtype">void</span> bindmemfunc(<span class="keyword">const</span> X *pthis, XMemFunc function_to_bind) {
<a name="l00712"></a>00712         bindconstmemfunc(pthis, function_to_bind);
<a name="l00713"></a>00713 <span class="preprocessor">#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)</span>
<a name="l00714"></a>00714 <span class="preprocessor"></span>        m_pStaticFunction = 0;
<a name="l00715"></a>00715 <span class="preprocessor">#endif</span>
<a name="l00716"></a>00716 <span class="preprocessor"></span>    }
<a name="l00717"></a>00717 <span class="preprocessor">#endif</span>
<a name="l00718"></a>00718 <span class="preprocessor"></span>    <span class="comment">// These functions are required for invoking the stored function</span>
<a name="l00719"></a>00719     <span class="keyword">inline</span> GenericClass *GetClosureThis()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_pthis; }
<a name="l00720"></a>00720     <span class="keyword">inline</span> GenericMemFunc GetClosureMemPtr()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>GenericMemFunc<span class="keyword">&gt;</span>(m_pFunction); }
<a name="l00721"></a>00721 
<a name="l00722"></a>00722 <span class="comment">// There are a few ways of dealing with static function pointers.</span>
<a name="l00723"></a>00723 <span class="comment">// There&#39;s a standard-compliant, but tricky method.</span>
<a name="l00724"></a>00724 <span class="comment">// There&#39;s also a straightforward hack, that won&#39;t work on DOS compilers using the</span>
<a name="l00725"></a>00725 <span class="comment">// medium memory model. It&#39;s so evil that I can&#39;t recommend it, but I&#39;ve</span>
<a name="l00726"></a>00726 <span class="comment">// implemented it anyway because it produces very nice asm code.</span>
<a name="l00727"></a>00727 
<a name="l00728"></a>00728 <span class="preprocessor">#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)</span>
<a name="l00729"></a>00729 <span class="preprocessor"></span>
<a name="l00730"></a>00730 <span class="comment">//              ClosurePtr&lt;&gt; - Safe version</span>
<a name="l00731"></a>00731 <span class="comment">//</span>
<a name="l00732"></a>00732 <span class="comment">// This implementation is standard-compliant, but a bit tricky.</span>
<a name="l00733"></a>00733 <span class="comment">// I store the function pointer inside the class, and the delegate then</span>
<a name="l00734"></a>00734 <span class="comment">// points to itself. Whenever the delegate is copied, these self-references</span>
<a name="l00735"></a>00735 <span class="comment">// must be transformed, and this complicates the = and == operators.</span>
<a name="l00736"></a>00736 <span class="keyword">public</span>:
<a name="l00737"></a>00737     <span class="comment">// The next two functions are for operator ==, =, and the copy constructor.</span>
<a name="l00738"></a>00738     <span class="comment">// We may need to convert the m_pthis pointers, so that</span>
<a name="l00739"></a>00739     <span class="comment">// they remain as self-references.</span>
<a name="l00740"></a>00740     <span class="keyword">template</span>&lt; <span class="keyword">class</span> DerivedClass &gt;
<a name="l00741"></a>00741     <span class="keyword">inline</span> <span class="keywordtype">void</span> CopyFrom (DerivedClass *pParent, <span class="keyword">const</span> delegate_memento &amp;x) {
<a name="l00742"></a>00742         set_mementoFrom(x);
<a name="l00743"></a>00743         <span class="keywordflow">if</span> (m_pStaticFunction!=0) {
<a name="l00744"></a>00744             <span class="comment">// transform self references...</span>
<a name="l00745"></a>00745             m_pthis=<span class="keyword">reinterpret_cast&lt;</span>GenericClass *<span class="keyword">&gt;</span>(pParent);
<a name="l00746"></a>00746         }
<a name="l00747"></a>00747     }
<a name="l00748"></a>00748     <span class="comment">// For static functions, the &#39;static_function_invoker&#39; class in the parent </span>
<a name="l00749"></a>00749     <span class="comment">// will be called. The parent then needs to call GetStaticFunction() to find out </span>
<a name="l00750"></a>00750     <span class="comment">// the actual function to invoke.</span>
<a name="l00751"></a>00751     <span class="keyword">template</span> &lt; <span class="keyword">class</span> DerivedClass, <span class="keyword">class</span> ParentInvokerSig &gt;
<a name="l00752"></a>00752     <span class="keyword">inline</span> <span class="keywordtype">void</span> bindstaticfunc(DerivedClass *pParent, ParentInvokerSig static_function_invoker, 
<a name="l00753"></a>00753                 StaticFuncPtr function_to_bind ) {
<a name="l00754"></a>00754         <span class="keywordflow">if</span> (function_to_bind==0) { <span class="comment">// cope with assignment to 0</span>
<a name="l00755"></a>00755             m_pFunction=0;
<a name="l00756"></a>00756         } <span class="keywordflow">else</span> { 
<a name="l00757"></a>00757             bindmemfunc(pParent, static_function_invoker);
<a name="l00758"></a>00758         }
<a name="l00759"></a>00759         m_pStaticFunction=<span class="keyword">reinterpret_cast&lt;</span>GenericFuncPtr<span class="keyword">&gt;</span>(function_to_bind);
<a name="l00760"></a>00760     }
<a name="l00761"></a>00761     <span class="keyword">inline</span> UnvoidStaticFuncPtr GetStaticFunction()<span class="keyword"> const </span>{ 
<a name="l00762"></a>00762         <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>UnvoidStaticFuncPtr<span class="keyword">&gt;</span>(m_pStaticFunction); 
<a name="l00763"></a>00763     }
<a name="l00764"></a>00764 <span class="preprocessor">#else</span>
<a name="l00765"></a>00765 <span class="preprocessor"></span>
<a name="l00766"></a>00766 <span class="comment">//              ClosurePtr&lt;&gt; - Evil version</span>
<a name="l00767"></a>00767 <span class="comment">//</span>
<a name="l00768"></a>00768 <span class="comment">// For compilers where data pointers are at least as big as code pointers, it is </span>
<a name="l00769"></a>00769 <span class="comment">// possible to store the function pointer in the this pointer, using another </span>
<a name="l00770"></a>00770 <span class="comment">// horrible_cast. Invocation isn&#39;t any faster, but it saves 4 bytes, and</span>
<a name="l00771"></a>00771 <span class="comment">// speeds up comparison and assignment. If C++ provided direct language support</span>
<a name="l00772"></a>00772 <span class="comment">// for delegates, they would produce asm code that was almost identical to this.</span>
<a name="l00773"></a>00773 <span class="comment">// Note that the Sun C++ and MSVC documentation explicitly state that they </span>
<a name="l00774"></a>00774 <span class="comment">// support static_cast between void * and function pointers.</span>
<a name="l00775"></a>00775 
<a name="l00776"></a>00776     <span class="keyword">template</span>&lt; <span class="keyword">class</span> DerivedClass &gt;
<a name="l00777"></a>00777     <span class="keyword">inline</span> <span class="keywordtype">void</span> CopyFrom (DerivedClass <span class="comment">/* *pParent*/</span>, <span class="keyword">const</span> delegate_memento &amp;right) {
<a name="l00778"></a>00778         set_mementoFrom(right);
<a name="l00779"></a>00779     }
<a name="l00780"></a>00780     <span class="comment">// For static functions, the &#39;static_function_invoker&#39; class in the parent </span>
<a name="l00781"></a>00781     <span class="comment">// will be called. The parent then needs to call GetStaticFunction() to find out </span>
<a name="l00782"></a>00782     <span class="comment">// the actual function to invoke.</span>
<a name="l00783"></a>00783     <span class="comment">// ******** EVIL, EVIL CODE! *******</span>
<a name="l00784"></a>00784     <span class="keyword">template</span> &lt;  <span class="keyword">class</span> DerivedClass, <span class="keyword">class</span> ParentInvokerSig&gt;
<a name="l00785"></a>00785     <span class="keyword">inline</span> <span class="keywordtype">void</span> bindstaticfunc(DerivedClass *pParent, ParentInvokerSig static_function_invoker, 
<a name="l00786"></a>00786                 StaticFuncPtr function_to_bind) {
<a name="l00787"></a>00787         <span class="keywordflow">if</span> (function_to_bind==0) { <span class="comment">// cope with assignment to 0</span>
<a name="l00788"></a>00788             m_pFunction=0;
<a name="l00789"></a>00789         } <span class="keywordflow">else</span> { 
<a name="l00790"></a>00790            <span class="comment">// We&#39;ll be ignoring the &#39;this&#39; pointer, but we need to make sure we pass</span>
<a name="l00791"></a>00791            <span class="comment">// a valid value to bindmemfunc().</span>
<a name="l00792"></a>00792             bindmemfunc(pParent, static_function_invoker);
<a name="l00793"></a>00793         }
<a name="l00794"></a>00794 
<a name="l00795"></a>00795         <span class="comment">// WARNING! Evil hack. We store the function in the &#39;this&#39; pointer!</span>
<a name="l00796"></a>00796         <span class="comment">// Ensure that there&#39;s a compilation failure if function pointers </span>
<a name="l00797"></a>00797         <span class="comment">// and data pointers have different sizes.</span>
<a name="l00798"></a>00798         <span class="comment">// If you get this error, you need to #undef FASTDELEGATE_USESTATICFUNCTIONHACK.</span>
<a name="l00799"></a>00799         <span class="keyword">typedef</span> <span class="keywordtype">int</span> ERROR_CantUseEvilMethod[<span class="keyword">sizeof</span>(GenericClass *)==<span class="keyword">sizeof</span>(function_to_bind) ? 1 : -1];
<a name="l00800"></a>00800         m_pthis = horrible_cast&lt;GenericClass *&gt;(function_to_bind);
<a name="l00801"></a>00801         <span class="comment">// MSVC, SunC++ and DMC accept the following (non-standard) code:</span>
<a name="l00802"></a>00802 <span class="comment">//      m_pthis = static_cast&lt;GenericClass *&gt;(static_cast&lt;void *&gt;(function_to_bind));</span>
<a name="l00803"></a>00803         <span class="comment">// BCC32, Comeau and DMC accept this method. MSVC7.1 needs __int64 instead of long</span>
<a name="l00804"></a>00804 <span class="comment">//      m_pthis = reinterpret_cast&lt;GenericClass *&gt;(reinterpret_cast&lt;long&gt;(function_to_bind));</span>
<a name="l00805"></a>00805     }
<a name="l00806"></a>00806     <span class="comment">// ******** EVIL, EVIL CODE! *******</span>
<a name="l00807"></a>00807     <span class="comment">// This function will be called with an invalid &#39;this&#39; pointer!!</span>
<a name="l00808"></a>00808     <span class="comment">// We&#39;re just returning the &#39;this&#39; pointer, converted into</span>
<a name="l00809"></a>00809     <span class="comment">// a function pointer!</span>
<a name="l00810"></a>00810     <span class="keyword">inline</span> UnvoidStaticFuncPtr GetStaticFunction()<span class="keyword"> const </span>{
<a name="l00811"></a>00811         <span class="comment">// Ensure that there&#39;s a compilation failure if function pointers </span>
<a name="l00812"></a>00812         <span class="comment">// and data pointers have different sizes.</span>
<a name="l00813"></a>00813         <span class="comment">// If you get this error, you need to #undef FASTDELEGATE_USESTATICFUNCTIONHACK.</span>
<a name="l00814"></a>00814         <span class="keyword">typedef</span> <span class="keywordtype">int</span> ERROR_CantUseEvilMethod[<span class="keyword">sizeof</span>(UnvoidStaticFuncPtr)==<span class="keyword">sizeof</span>(<span class="keyword">this</span>) ? 1 : -1];
<a name="l00815"></a>00815         <span class="keywordflow">return</span> horrible_cast&lt;UnvoidStaticFuncPtr&gt;(<span class="keyword">this</span>);
<a name="l00816"></a>00816     }
<a name="l00817"></a>00817 <span class="preprocessor">#endif // !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)</span>
<a name="l00818"></a>00818 <span class="preprocessor"></span>
<a name="l00819"></a>00819     <span class="comment">// Does the closure contain this static function?</span>
<a name="l00820"></a>00820     <span class="keyword">inline</span> <span class="keywordtype">bool</span> IsEqualToStaticFuncPtr(StaticFuncPtr funcptr){
<a name="l00821"></a>00821         <span class="keywordflow">if</span> (funcptr==0) <span class="keywordflow">return</span> empty(); 
<a name="l00822"></a>00822     <span class="comment">// For the Evil method, if it doesn&#39;t actually contain a static function, this will return an arbitrary</span>
<a name="l00823"></a>00823     <span class="comment">// value that is not equal to any valid function pointer.</span>
<a name="l00824"></a>00824         <span class="keywordflow">else</span> <span class="keywordflow">return</span> funcptr==<span class="keyword">reinterpret_cast&lt;</span>StaticFuncPtr<span class="keyword">&gt;</span>(GetStaticFunction());
<a name="l00825"></a>00825     }
<a name="l00826"></a>00826 };
<a name="l00827"></a>00827 
<a name="l00828"></a>00828 
<a name="l00829"></a>00829 } <span class="comment">// namespace detail</span>
<a name="l00830"></a>00830 <span class="comment"></span>
<a name="l00831"></a>00831 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00832"></a>00832 <span class="comment"></span><span class="comment">//                      Fast Delegates, part 3:</span>
<a name="l00833"></a>00833 <span class="comment">//</span>
<a name="l00834"></a>00834 <span class="comment">//              Wrapper classes to ensure type safety</span>
<a name="l00835"></a>00835 <span class="comment">//</span><span class="comment"></span>
<a name="l00836"></a>00836 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00837"></a>00837 <span class="comment"></span>
<a name="l00838"></a>00838 
<a name="l00839"></a>00839 <span class="comment">// Once we have the member function conversion templates, it&#39;s easy to make the</span>
<a name="l00840"></a>00840 <span class="comment">// wrapper classes. So that they will work with as many compilers as possible, </span>
<a name="l00841"></a>00841 <span class="comment">// the classes are of the form</span>
<a name="l00842"></a>00842 <span class="comment">//   fast_delegate3&lt;int, char *, double&gt;</span>
<a name="l00843"></a>00843 <span class="comment">// They can cope with any combination of parameters. The max number of parameters</span>
<a name="l00844"></a>00844 <span class="comment">// allowed is 8, but it is trivial to increase this limit.</span>
<a name="l00845"></a>00845 <span class="comment">// Note that we need to treat const member functions seperately.</span>
<a name="l00846"></a>00846 <span class="comment">// All this class does is to enforce type safety, and invoke the delegate with</span>
<a name="l00847"></a>00847 <span class="comment">// the correct list of parameters.</span>
<a name="l00848"></a>00848 
<a name="l00849"></a>00849 <span class="comment">// Because of the weird rule about the class of derived member function pointers,</span>
<a name="l00850"></a>00850 <span class="comment">// you sometimes need to apply a downcast to the &#39;this&#39; pointer.</span>
<a name="l00851"></a>00851 <span class="comment">// This is the reason for the use of &quot;implicit_cast&lt;X*&gt;(pthis)&quot; in the code below. </span>
<a name="l00852"></a>00852 <span class="comment">// If CDerivedClass is derived from CBaseClass, but doesn&#39;t override SimpleVirtualFunction,</span>
<a name="l00853"></a>00853 <span class="comment">// without this trick you&#39;d need to write:</span>
<a name="l00854"></a>00854 <span class="comment">//      MyDelegate(static_cast&lt;CBaseClass *&gt;(&amp;d), &amp;CDerivedClass::SimpleVirtualFunction);</span>
<a name="l00855"></a>00855 <span class="comment">// but with the trick you can write</span>
<a name="l00856"></a>00856 <span class="comment">//      MyDelegate(&amp;d, &amp;CDerivedClass::SimpleVirtualFunction);</span>
<a name="l00857"></a>00857 
<a name="l00858"></a>00858 <span class="comment">// RetType is the type the compiler uses in compiling the template. For VC6,</span>
<a name="l00859"></a>00859 <span class="comment">// it cannot be void. result_type is the real type which is returned from</span>
<a name="l00860"></a>00860 <span class="comment">// all of the functions. It can be void.</span>
<a name="l00861"></a>00861 
<a name="l00862"></a>00862 <span class="comment">// Implicit conversion to &quot;bool&quot; is achieved using the safe_bool idiom,</span>
<a name="l00863"></a>00863 <span class="comment">// using member data pointers (MDP). This allows &quot;if (dg)...&quot; syntax</span>
<a name="l00864"></a>00864 <span class="comment">// Because some compilers (eg codeplay) don&#39;t have a unique value for a zero</span>
<a name="l00865"></a>00865 <span class="comment">// MDP, an extra padding member is added to the SafeBool struct.</span>
<a name="l00866"></a>00866 <span class="comment">// Some compilers (eg VC6) won&#39;t implicitly convert from 0 to an MDP, so</span>
<a name="l00867"></a>00867 <span class="comment">// in that case the static function constructor is not made explicit; this</span>
<a name="l00868"></a>00868 <span class="comment">// allows &quot;if (dg==0) ...&quot; to compile.</span>
<a name="l00869"></a>00869 
<a name="l00870"></a>00870 <span class="comment">//N=0</span>
<a name="l00871"></a>00871 <span class="keyword">template</span>&lt;<span class="keyword">class</span> RetType=detail::DefaultVo<span class="keywordtype">id</span>&gt;
<a name="l00872"></a>00872 <span class="keyword">class </span>fast_delegate0 {
<a name="l00873"></a>00873 <span class="keyword">public</span>:
<a name="l00874"></a>00874     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::idl::detail::default_void_to_void&lt;RetType&gt;::type result_type;
<a name="l00875"></a>00875 <span class="keyword">private</span>:
<a name="l00876"></a>00876     <span class="keyword">typedef</span> result_type (*StaticFunctionPtr)();
<a name="l00877"></a>00877     <span class="keyword">typedef</span> RetType (*UnvoidStaticFunctionPtr)();
<a name="l00878"></a>00878     <span class="keyword">typedef</span> RetType (boost::idl::detail::GenericClass::*GenericMemFn)();
<a name="l00879"></a>00879     <span class="keyword">typedef</span> boost::idl::detail::ClosurePtr&lt;GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr&gt; ClosureType;
<a name="l00880"></a>00880     ClosureType m_Closure;
<a name="l00881"></a>00881 <span class="keyword">public</span>:
<a name="l00882"></a>00882     <span class="comment">// Typedefs to aid generic programming</span>
<a name="l00883"></a>00883     <span class="keyword">typedef</span> fast_delegate0 type;
<a name="l00884"></a>00884 
<a name="l00885"></a>00885     <span class="comment">// Construction and comparison functions</span>
<a name="l00886"></a>00886     fast_delegate0() { clear(); }
<a name="l00887"></a>00887     fast_delegate0(<span class="keyword">const</span> fast_delegate0 &amp;x) {
<a name="l00888"></a>00888         m_Closure.CopyFrom(<span class="keyword">this</span>, x.m_Closure); }
<a name="l00889"></a>00889     <span class="keywordtype">void</span> operator = (<span class="keyword">const</span> fast_delegate0 &amp;x)  {
<a name="l00890"></a>00890         m_Closure.CopyFrom(<span class="keyword">this</span>, x.m_Closure); }
<a name="l00891"></a>00891     <span class="keywordtype">bool</span> operator ==(<span class="keyword">const</span> fast_delegate0 &amp;x)<span class="keyword"> const </span>{
<a name="l00892"></a>00892         <span class="keywordflow">return</span> m_Closure.IsEqual(x.m_Closure);  }
<a name="l00893"></a>00893     <span class="keywordtype">bool</span> operator !=(<span class="keyword">const</span> fast_delegate0 &amp;x)<span class="keyword"> const </span>{
<a name="l00894"></a>00894         <span class="keywordflow">return</span> !m_Closure.IsEqual(x.m_Closure); }
<a name="l00895"></a>00895     <span class="keywordtype">bool</span> operator &lt;(<span class="keyword">const</span> fast_delegate0 &amp;x)<span class="keyword"> const </span>{
<a name="l00896"></a>00896         <span class="keywordflow">return</span> m_Closure.IsLess(x.m_Closure);   }
<a name="l00897"></a>00897     <span class="keywordtype">bool</span> operator &gt;(<span class="keyword">const</span> fast_delegate0 &amp;x)<span class="keyword"> const </span>{
<a name="l00898"></a>00898         <span class="keywordflow">return</span> x.m_Closure.IsLess(m_Closure);   }
<a name="l00899"></a>00899     <span class="comment">// Binding to non-const member functions</span>
<a name="l00900"></a>00900     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l00901"></a>00901     fast_delegate0(Y *pthis, result_type (X::* function_to_bind)() ) {
<a name="l00902"></a>00902         m_Closure.bindmemfunc(boost::idl::detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind); }
<a name="l00903"></a>00903     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l00904"></a>00904     <span class="keyword">inline</span> <span class="keywordtype">void</span> bind(Y *pthis, result_type (X::* function_to_bind)()) {
<a name="l00905"></a>00905         m_Closure.bindmemfunc(boost::idl::detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind);  }
<a name="l00906"></a>00906     <span class="comment">// Binding to const member functions.</span>
<a name="l00907"></a>00907     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l00908"></a>00908     fast_delegate0(<span class="keyword">const</span> Y *pthis, result_type (X::* function_to_bind)() <span class="keyword">const</span>) {
<a name="l00909"></a>00909         m_Closure.bindconstmemfunc(boost::idl::detail::implicit_cast&lt;const X*&gt;(pthis), function_to_bind);   }
<a name="l00910"></a>00910     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l00911"></a>00911     <span class="keyword">inline</span> <span class="keywordtype">void</span> bind(<span class="keyword">const</span> Y *pthis, result_type (X::* function_to_bind)() <span class="keyword">const</span>) {
<a name="l00912"></a>00912         m_Closure.bindconstmemfunc(boost::idl::detail::implicit_cast&lt;const X *&gt;(pthis), function_to_bind);  }
<a name="l00913"></a>00913     <span class="comment">// Static functions. We convert them into a member function call.</span>
<a name="l00914"></a>00914     <span class="comment">// This constructor also provides implicit conversion</span>
<a name="l00915"></a>00915     fast_delegate0(result_type (*function_to_bind)() ) {
<a name="l00916"></a>00916         bind(function_to_bind); }
<a name="l00917"></a>00917     <span class="comment">// for efficiency, prevent creation of a temporary</span>
<a name="l00918"></a>00918     <span class="keywordtype">void</span> operator = (result_type (*function_to_bind)() ) {
<a name="l00919"></a>00919         bind(function_to_bind); }
<a name="l00920"></a>00920     <span class="keyword">inline</span> <span class="keywordtype">void</span> bind(result_type (*function_to_bind)()) {
<a name="l00921"></a>00921         m_Closure.bindstaticfunc(<span class="keyword">this</span>, &amp;fast_delegate0::InvokeStaticFunction, 
<a name="l00922"></a>00922             function_to_bind); }
<a name="l00923"></a>00923     <span class="comment">// Invoke the delegate</span>
<a name="l00924"></a>00924     RetType operator() ()<span class="keyword"> const </span>{
<a name="l00925"></a>00925     <span class="keywordflow">return</span> (m_Closure.GetClosureThis()-&gt;*(m_Closure.GetClosureMemPtr()))(); }
<a name="l00926"></a>00926     <span class="comment">// Implicit conversion to &quot;bool&quot; using the safe_bool idiom</span>
<a name="l00927"></a>00927 <span class="keyword">private</span>:
<a name="l00928"></a>00928     <span class="keyword">typedef</span> <span class="keyword">struct </span>SafeBoolStruct {
<a name="l00929"></a>00929         <span class="keywordtype">int</span> a_data_pointer_to_this_is_0_on_buggy_compilers;
<a name="l00930"></a>00930         StaticFunctionPtr m_nonzero;
<a name="l00931"></a>00931     } UselessTypedef;
<a name="l00932"></a>00932     <span class="keyword">typedef</span> StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
<a name="l00933"></a>00933 <span class="keyword">public</span>:
<a name="l00934"></a>00934     operator unspecified_bool_type()<span class="keyword"> const </span>{
<a name="l00935"></a>00935         <span class="keywordflow">return</span> empty()? 0: &amp;SafeBoolStruct::m_nonzero;
<a name="l00936"></a>00936     }
<a name="l00937"></a>00937     <span class="comment">// necessary to allow ==0 to work despite the safe_bool idiom</span>
<a name="l00938"></a>00938     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(StaticFunctionPtr funcptr) {
<a name="l00939"></a>00939         <span class="keywordflow">return</span> m_Closure.IsEqualToStaticFuncPtr(funcptr);   }
<a name="l00940"></a>00940     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator!=(StaticFunctionPtr funcptr) { 
<a name="l00941"></a>00941         <span class="keywordflow">return</span> !m_Closure.IsEqualToStaticFuncPtr(funcptr);    }
<a name="l00942"></a>00942     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator ! ()<span class="keyword"> const </span>{   <span class="comment">// Is it bound to anything?</span>
<a name="l00943"></a>00943             <span class="keywordflow">return</span> !m_Closure; }
<a name="l00944"></a>00944     <span class="keyword">inline</span> <span class="keywordtype">bool</span> empty()<span class="keyword"> const   </span>{
<a name="l00945"></a>00945             <span class="keywordflow">return</span> !m_Closure; }
<a name="l00946"></a>00946     <span class="keywordtype">void</span> clear() { m_Closure.clear();}
<a name="l00947"></a>00947     <span class="comment">// Conversion to and from the delegate_memento storage class</span>
<a name="l00948"></a>00948     <span class="keyword">const</span> delegate_memento &amp; get_memento()<span class="keyword">const </span>{ <span class="keywordflow">return</span> m_Closure; }
<a name="l00949"></a>00949     <span class="keywordtype">void</span> set_memento(<span class="keyword">const</span> delegate_memento &amp;any) { m_Closure.CopyFrom(<span class="keyword">this</span>, any); }
<a name="l00950"></a>00950 
<a name="l00951"></a>00951 <span class="keyword">private</span>:    <span class="comment">// Invoker for static functions</span>
<a name="l00952"></a>00952     RetType InvokeStaticFunction()<span class="keyword"> const </span>{
<a name="l00953"></a>00953     <span class="keywordflow">return</span> (*(m_Closure.GetStaticFunction()))(); }
<a name="l00954"></a>00954 };
<a name="l00955"></a>00955 
<a name="l00956"></a>00956 <span class="comment">//N=1</span>
<a name="l00957"></a>00957 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Param1, <span class="keyword">class</span> RetType=detail::DefaultVo<span class="keywordtype">id</span>&gt;
<a name="l00958"></a>00958 <span class="keyword">class </span>fast_delegate1 {
<a name="l00959"></a>00959 <span class="keyword">public</span>:
<a name="l00960"></a>00960     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::idl::detail::default_void_to_void&lt;RetType&gt;::type result_type;
<a name="l00961"></a>00961 <span class="keyword">private</span>:
<a name="l00962"></a>00962     <span class="keyword">typedef</span> result_type (*StaticFunctionPtr)(Param1 p1);
<a name="l00963"></a>00963     <span class="keyword">typedef</span> RetType (*UnvoidStaticFunctionPtr)(Param1 p1);
<a name="l00964"></a>00964     <span class="keyword">typedef</span> RetType (boost::idl::detail::GenericClass::*GenericMemFn)(Param1 p1);
<a name="l00965"></a>00965     <span class="keyword">typedef</span> boost::idl::detail::ClosurePtr&lt;GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr&gt; ClosureType;
<a name="l00966"></a>00966     ClosureType m_Closure;
<a name="l00967"></a>00967 <span class="keyword">public</span>:
<a name="l00968"></a>00968     <span class="comment">// Typedefs to aid generic programming</span>
<a name="l00969"></a>00969     <span class="keyword">typedef</span> fast_delegate1 type;
<a name="l00970"></a>00970 
<a name="l00971"></a>00971     <span class="comment">// Construction and comparison functions</span>
<a name="l00972"></a>00972     fast_delegate1() { clear(); }
<a name="l00973"></a>00973     fast_delegate1(<span class="keyword">const</span> fast_delegate1 &amp;x) {
<a name="l00974"></a>00974         m_Closure.CopyFrom(<span class="keyword">this</span>, x.m_Closure); }
<a name="l00975"></a>00975     <span class="keywordtype">void</span> operator = (<span class="keyword">const</span> fast_delegate1 &amp;x)  {
<a name="l00976"></a>00976         m_Closure.CopyFrom(<span class="keyword">this</span>, x.m_Closure); }
<a name="l00977"></a>00977     <span class="keywordtype">bool</span> operator ==(<span class="keyword">const</span> fast_delegate1 &amp;x)<span class="keyword"> const </span>{
<a name="l00978"></a>00978         <span class="keywordflow">return</span> m_Closure.IsEqual(x.m_Closure);  }
<a name="l00979"></a>00979     <span class="keywordtype">bool</span> operator !=(<span class="keyword">const</span> fast_delegate1 &amp;x)<span class="keyword"> const </span>{
<a name="l00980"></a>00980         <span class="keywordflow">return</span> !m_Closure.IsEqual(x.m_Closure); }
<a name="l00981"></a>00981     <span class="keywordtype">bool</span> operator &lt;(<span class="keyword">const</span> fast_delegate1 &amp;x)<span class="keyword"> const </span>{
<a name="l00982"></a>00982         <span class="keywordflow">return</span> m_Closure.IsLess(x.m_Closure);   }
<a name="l00983"></a>00983     <span class="keywordtype">bool</span> operator &gt;(<span class="keyword">const</span> fast_delegate1 &amp;x)<span class="keyword"> const </span>{
<a name="l00984"></a>00984         <span class="keywordflow">return</span> x.m_Closure.IsLess(m_Closure);   }
<a name="l00985"></a>00985     <span class="comment">// Binding to non-const member functions</span>
<a name="l00986"></a>00986     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l00987"></a>00987     fast_delegate1(Y *pthis, result_type (X::* function_to_bind)(Param1 p1) ) {
<a name="l00988"></a>00988         m_Closure.bindmemfunc(boost::idl::detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind); }
<a name="l00989"></a>00989     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l00990"></a>00990     <span class="keyword">inline</span> <span class="keywordtype">void</span> bind(Y *pthis, result_type (X::* function_to_bind)(Param1 p1)) {
<a name="l00991"></a>00991         m_Closure.bindmemfunc(boost::idl::detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind);  }
<a name="l00992"></a>00992     <span class="comment">// Binding to const member functions.</span>
<a name="l00993"></a>00993     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l00994"></a>00994     fast_delegate1(<span class="keyword">const</span> Y *pthis, result_type (X::* function_to_bind)(Param1 p1) <span class="keyword">const</span>) {
<a name="l00995"></a>00995         m_Closure.bindconstmemfunc(boost::idl::detail::implicit_cast&lt;const X*&gt;(pthis), function_to_bind);   }
<a name="l00996"></a>00996     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l00997"></a>00997     <span class="keyword">inline</span> <span class="keywordtype">void</span> bind(<span class="keyword">const</span> Y *pthis, result_type (X::* function_to_bind)(Param1 p1) <span class="keyword">const</span>) {
<a name="l00998"></a>00998         m_Closure.bindconstmemfunc(boost::idl::detail::implicit_cast&lt;const X *&gt;(pthis), function_to_bind);  }
<a name="l00999"></a>00999     <span class="comment">// Static functions. We convert them into a member function call.</span>
<a name="l01000"></a>01000     <span class="comment">// This constructor also provides implicit conversion</span>
<a name="l01001"></a>01001     fast_delegate1(result_type (*function_to_bind)(Param1 p1) ) {
<a name="l01002"></a>01002         bind(function_to_bind); }
<a name="l01003"></a>01003     <span class="comment">// for efficiency, prevent creation of a temporary</span>
<a name="l01004"></a>01004     <span class="keywordtype">void</span> operator = (result_type (*function_to_bind)(Param1 p1) ) {
<a name="l01005"></a>01005         bind(function_to_bind); }
<a name="l01006"></a>01006     <span class="keyword">inline</span> <span class="keywordtype">void</span> bind(result_type (*function_to_bind)(Param1 p1)) {
<a name="l01007"></a>01007         m_Closure.bindstaticfunc(<span class="keyword">this</span>, &amp;fast_delegate1::InvokeStaticFunction, 
<a name="l01008"></a>01008             function_to_bind); }
<a name="l01009"></a>01009     <span class="comment">// Invoke the delegate</span>
<a name="l01010"></a>01010     RetType operator() (Param1 p1)<span class="keyword"> const </span>{
<a name="l01011"></a>01011     <span class="keywordflow">return</span> (m_Closure.GetClosureThis()-&gt;*(m_Closure.GetClosureMemPtr()))(p1); }
<a name="l01012"></a>01012     <span class="comment">// Implicit conversion to &quot;bool&quot; using the safe_bool idiom</span>
<a name="l01013"></a>01013 <span class="keyword">private</span>:
<a name="l01014"></a>01014     <span class="keyword">typedef</span> <span class="keyword">struct </span>SafeBoolStruct {
<a name="l01015"></a>01015         <span class="keywordtype">int</span> a_data_pointer_to_this_is_0_on_buggy_compilers;
<a name="l01016"></a>01016         StaticFunctionPtr m_nonzero;
<a name="l01017"></a>01017     } UselessTypedef;
<a name="l01018"></a>01018     <span class="keyword">typedef</span> StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
<a name="l01019"></a>01019 <span class="keyword">public</span>:
<a name="l01020"></a>01020     operator unspecified_bool_type()<span class="keyword"> const </span>{
<a name="l01021"></a>01021         <span class="keywordflow">return</span> empty()? 0: &amp;SafeBoolStruct::m_nonzero;
<a name="l01022"></a>01022     }
<a name="l01023"></a>01023     <span class="comment">// necessary to allow ==0 to work despite the safe_bool idiom</span>
<a name="l01024"></a>01024     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(StaticFunctionPtr funcptr) {
<a name="l01025"></a>01025         <span class="keywordflow">return</span> m_Closure.IsEqualToStaticFuncPtr(funcptr);   }
<a name="l01026"></a>01026     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator!=(StaticFunctionPtr funcptr) { 
<a name="l01027"></a>01027         <span class="keywordflow">return</span> !m_Closure.IsEqualToStaticFuncPtr(funcptr);    }
<a name="l01028"></a>01028     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator ! ()<span class="keyword"> const </span>{   <span class="comment">// Is it bound to anything?</span>
<a name="l01029"></a>01029             <span class="keywordflow">return</span> !m_Closure; }
<a name="l01030"></a>01030     <span class="keyword">inline</span> <span class="keywordtype">bool</span> empty()<span class="keyword"> const   </span>{
<a name="l01031"></a>01031             <span class="keywordflow">return</span> !m_Closure; }
<a name="l01032"></a>01032     <span class="keywordtype">void</span> clear() { m_Closure.clear();}
<a name="l01033"></a>01033     <span class="comment">// Conversion to and from the delegate_memento storage class</span>
<a name="l01034"></a>01034     <span class="keyword">const</span> delegate_memento &amp; get_memento()<span class="keyword">const </span>{ <span class="keywordflow">return</span> m_Closure; }
<a name="l01035"></a>01035     <span class="keywordtype">void</span> set_memento(<span class="keyword">const</span> delegate_memento &amp;any) { m_Closure.CopyFrom(<span class="keyword">this</span>, any); }
<a name="l01036"></a>01036 
<a name="l01037"></a>01037 <span class="keyword">private</span>:    <span class="comment">// Invoker for static functions</span>
<a name="l01038"></a>01038     RetType InvokeStaticFunction(Param1 p1)<span class="keyword"> const </span>{
<a name="l01039"></a>01039     <span class="keywordflow">return</span> (*(m_Closure.GetStaticFunction()))(p1); }
<a name="l01040"></a>01040 };
<a name="l01041"></a>01041 
<a name="l01042"></a>01042 <span class="comment">//N=2</span>
<a name="l01043"></a>01043 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Param1, <span class="keyword">class</span> Param2, <span class="keyword">class</span> RetType=detail::DefaultVo<span class="keywordtype">id</span>&gt;
<a name="l01044"></a>01044 <span class="keyword">class </span>fast_delegate2 {
<a name="l01045"></a>01045 <span class="keyword">public</span>:
<a name="l01046"></a>01046     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::idl::detail::default_void_to_void&lt;RetType&gt;::type result_type;
<a name="l01047"></a>01047 <span class="keyword">private</span>:
<a name="l01048"></a>01048     <span class="keyword">typedef</span> result_type (*StaticFunctionPtr)(Param1 p1, Param2 p2);
<a name="l01049"></a>01049     <span class="keyword">typedef</span> RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2);
<a name="l01050"></a>01050     <span class="keyword">typedef</span> RetType (boost::idl::detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2);
<a name="l01051"></a>01051     <span class="keyword">typedef</span> boost::idl::detail::ClosurePtr&lt;GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr&gt; ClosureType;
<a name="l01052"></a>01052     ClosureType m_Closure;
<a name="l01053"></a>01053 <span class="keyword">public</span>:
<a name="l01054"></a>01054     <span class="comment">// Typedefs to aid generic programming</span>
<a name="l01055"></a>01055     <span class="keyword">typedef</span> fast_delegate2 type;
<a name="l01056"></a>01056 
<a name="l01057"></a>01057     <span class="comment">// Construction and comparison functions</span>
<a name="l01058"></a>01058     fast_delegate2() { clear(); }
<a name="l01059"></a>01059     fast_delegate2(<span class="keyword">const</span> fast_delegate2 &amp;x) {
<a name="l01060"></a>01060         m_Closure.CopyFrom(<span class="keyword">this</span>, x.m_Closure); }
<a name="l01061"></a>01061     <span class="keywordtype">void</span> operator = (<span class="keyword">const</span> fast_delegate2 &amp;x)  {
<a name="l01062"></a>01062         m_Closure.CopyFrom(<span class="keyword">this</span>, x.m_Closure); }
<a name="l01063"></a>01063     <span class="keywordtype">bool</span> operator ==(<span class="keyword">const</span> fast_delegate2 &amp;x)<span class="keyword"> const </span>{
<a name="l01064"></a>01064         <span class="keywordflow">return</span> m_Closure.IsEqual(x.m_Closure);  }
<a name="l01065"></a>01065     <span class="keywordtype">bool</span> operator !=(<span class="keyword">const</span> fast_delegate2 &amp;x)<span class="keyword"> const </span>{
<a name="l01066"></a>01066         <span class="keywordflow">return</span> !m_Closure.IsEqual(x.m_Closure); }
<a name="l01067"></a>01067     <span class="keywordtype">bool</span> operator &lt;(<span class="keyword">const</span> fast_delegate2 &amp;x)<span class="keyword"> const </span>{
<a name="l01068"></a>01068         <span class="keywordflow">return</span> m_Closure.IsLess(x.m_Closure);   }
<a name="l01069"></a>01069     <span class="keywordtype">bool</span> operator &gt;(<span class="keyword">const</span> fast_delegate2 &amp;x)<span class="keyword"> const </span>{
<a name="l01070"></a>01070         <span class="keywordflow">return</span> x.m_Closure.IsLess(m_Closure);   }
<a name="l01071"></a>01071     <span class="comment">// Binding to non-const member functions</span>
<a name="l01072"></a>01072     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01073"></a>01073     fast_delegate2(Y *pthis, result_type (X::* function_to_bind)(Param1 p1, Param2 p2) ) {
<a name="l01074"></a>01074         m_Closure.bindmemfunc(boost::idl::detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind); }
<a name="l01075"></a>01075     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01076"></a>01076     <span class="keyword">inline</span> <span class="keywordtype">void</span> bind(Y *pthis, result_type (X::* function_to_bind)(Param1 p1, Param2 p2)) {
<a name="l01077"></a>01077         m_Closure.bindmemfunc(boost::idl::detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind);  }
<a name="l01078"></a>01078     <span class="comment">// Binding to const member functions.</span>
<a name="l01079"></a>01079     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01080"></a>01080     fast_delegate2(<span class="keyword">const</span> Y *pthis, result_type (X::* function_to_bind)(Param1 p1, Param2 p2) <span class="keyword">const</span>) {
<a name="l01081"></a>01081         m_Closure.bindconstmemfunc(boost::idl::detail::implicit_cast&lt;const X*&gt;(pthis), function_to_bind);   }
<a name="l01082"></a>01082     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01083"></a>01083     <span class="keyword">inline</span> <span class="keywordtype">void</span> bind(<span class="keyword">const</span> Y *pthis, result_type (X::* function_to_bind)(Param1 p1, Param2 p2) <span class="keyword">const</span>) {
<a name="l01084"></a>01084         m_Closure.bindconstmemfunc(boost::idl::detail::implicit_cast&lt;const X *&gt;(pthis), function_to_bind);  }
<a name="l01085"></a>01085     <span class="comment">// Static functions. We convert them into a member function call.</span>
<a name="l01086"></a>01086     <span class="comment">// This constructor also provides implicit conversion</span>
<a name="l01087"></a>01087     fast_delegate2(result_type (*function_to_bind)(Param1 p1, Param2 p2) ) {
<a name="l01088"></a>01088         bind(function_to_bind); }
<a name="l01089"></a>01089     <span class="comment">// for efficiency, prevent creation of a temporary</span>
<a name="l01090"></a>01090     <span class="keywordtype">void</span> operator = (result_type (*function_to_bind)(Param1 p1, Param2 p2) ) {
<a name="l01091"></a>01091         bind(function_to_bind); }
<a name="l01092"></a>01092     <span class="keyword">inline</span> <span class="keywordtype">void</span> bind(result_type (*function_to_bind)(Param1 p1, Param2 p2)) {
<a name="l01093"></a>01093         m_Closure.bindstaticfunc(<span class="keyword">this</span>, &amp;fast_delegate2::InvokeStaticFunction, 
<a name="l01094"></a>01094             function_to_bind); }
<a name="l01095"></a>01095     <span class="comment">// Invoke the delegate</span>
<a name="l01096"></a>01096     RetType operator() (Param1 p1, Param2 p2)<span class="keyword"> const </span>{
<a name="l01097"></a>01097     <span class="keywordflow">return</span> (m_Closure.GetClosureThis()-&gt;*(m_Closure.GetClosureMemPtr()))(p1, p2); }
<a name="l01098"></a>01098     <span class="comment">// Implicit conversion to &quot;bool&quot; using the safe_bool idiom</span>
<a name="l01099"></a>01099 <span class="keyword">private</span>:
<a name="l01100"></a>01100     <span class="keyword">typedef</span> <span class="keyword">struct </span>SafeBoolStruct {
<a name="l01101"></a>01101         <span class="keywordtype">int</span> a_data_pointer_to_this_is_0_on_buggy_compilers;
<a name="l01102"></a>01102         StaticFunctionPtr m_nonzero;
<a name="l01103"></a>01103     } UselessTypedef;
<a name="l01104"></a>01104     <span class="keyword">typedef</span> StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
<a name="l01105"></a>01105 <span class="keyword">public</span>:
<a name="l01106"></a>01106     operator unspecified_bool_type()<span class="keyword"> const </span>{
<a name="l01107"></a>01107         <span class="keywordflow">return</span> empty()? 0: &amp;SafeBoolStruct::m_nonzero;
<a name="l01108"></a>01108     }
<a name="l01109"></a>01109     <span class="comment">// necessary to allow ==0 to work despite the safe_bool idiom</span>
<a name="l01110"></a>01110     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(StaticFunctionPtr funcptr) {
<a name="l01111"></a>01111         <span class="keywordflow">return</span> m_Closure.IsEqualToStaticFuncPtr(funcptr);   }
<a name="l01112"></a>01112     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator!=(StaticFunctionPtr funcptr) { 
<a name="l01113"></a>01113         <span class="keywordflow">return</span> !m_Closure.IsEqualToStaticFuncPtr(funcptr);    }
<a name="l01114"></a>01114     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator ! ()<span class="keyword"> const </span>{   <span class="comment">// Is it bound to anything?</span>
<a name="l01115"></a>01115             <span class="keywordflow">return</span> !m_Closure; }
<a name="l01116"></a>01116     <span class="keyword">inline</span> <span class="keywordtype">bool</span> empty()<span class="keyword"> const   </span>{
<a name="l01117"></a>01117             <span class="keywordflow">return</span> !m_Closure; }
<a name="l01118"></a>01118     <span class="keywordtype">void</span> clear() { m_Closure.clear();}
<a name="l01119"></a>01119     <span class="comment">// Conversion to and from the delegate_memento storage class</span>
<a name="l01120"></a>01120     <span class="keyword">const</span> delegate_memento &amp; get_memento()<span class="keyword">const </span>{ <span class="keywordflow">return</span> m_Closure; }
<a name="l01121"></a>01121     <span class="keywordtype">void</span> set_memento(<span class="keyword">const</span> delegate_memento &amp;any) { m_Closure.CopyFrom(<span class="keyword">this</span>, any); }
<a name="l01122"></a>01122 
<a name="l01123"></a>01123 <span class="keyword">private</span>:    <span class="comment">// Invoker for static functions</span>
<a name="l01124"></a>01124     RetType InvokeStaticFunction(Param1 p1, Param2 p2)<span class="keyword"> const </span>{
<a name="l01125"></a>01125     <span class="keywordflow">return</span> (*(m_Closure.GetStaticFunction()))(p1, p2); }
<a name="l01126"></a>01126 };
<a name="l01127"></a>01127 
<a name="l01128"></a>01128 <span class="comment">//N=3</span>
<a name="l01129"></a>01129 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Param1, <span class="keyword">class</span> Param2, <span class="keyword">class</span> Param3, <span class="keyword">class</span> RetType=detail::DefaultVo<span class="keywordtype">id</span>&gt;
<a name="l01130"></a>01130 <span class="keyword">class </span>fast_delegate3 {
<a name="l01131"></a>01131 <span class="keyword">public</span>:
<a name="l01132"></a>01132     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::idl::detail::default_void_to_void&lt;RetType&gt;::type result_type;
<a name="l01133"></a>01133 <span class="keyword">private</span>:
<a name="l01134"></a>01134     <span class="keyword">typedef</span> result_type (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3);
<a name="l01135"></a>01135     <span class="keyword">typedef</span> RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3);
<a name="l01136"></a>01136     <span class="keyword">typedef</span> RetType (boost::idl::detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3);
<a name="l01137"></a>01137     <span class="keyword">typedef</span> boost::idl::detail::ClosurePtr&lt;GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr&gt; ClosureType;
<a name="l01138"></a>01138     ClosureType m_Closure;
<a name="l01139"></a>01139 <span class="keyword">public</span>:
<a name="l01140"></a>01140     <span class="comment">// Typedefs to aid generic programming</span>
<a name="l01141"></a>01141     <span class="keyword">typedef</span> fast_delegate3 type;
<a name="l01142"></a>01142 
<a name="l01143"></a>01143     <span class="comment">// Construction and comparison functions</span>
<a name="l01144"></a>01144     fast_delegate3() { clear(); }
<a name="l01145"></a>01145     fast_delegate3(<span class="keyword">const</span> fast_delegate3 &amp;x) {
<a name="l01146"></a>01146         m_Closure.CopyFrom(<span class="keyword">this</span>, x.m_Closure); }
<a name="l01147"></a>01147     <span class="keywordtype">void</span> operator = (<span class="keyword">const</span> fast_delegate3 &amp;x)  {
<a name="l01148"></a>01148         m_Closure.CopyFrom(<span class="keyword">this</span>, x.m_Closure); }
<a name="l01149"></a>01149     <span class="keywordtype">bool</span> operator ==(<span class="keyword">const</span> fast_delegate3 &amp;x)<span class="keyword"> const </span>{
<a name="l01150"></a>01150         <span class="keywordflow">return</span> m_Closure.IsEqual(x.m_Closure);  }
<a name="l01151"></a>01151     <span class="keywordtype">bool</span> operator !=(<span class="keyword">const</span> fast_delegate3 &amp;x)<span class="keyword"> const </span>{
<a name="l01152"></a>01152         <span class="keywordflow">return</span> !m_Closure.IsEqual(x.m_Closure); }
<a name="l01153"></a>01153     <span class="keywordtype">bool</span> operator &lt;(<span class="keyword">const</span> fast_delegate3 &amp;x)<span class="keyword"> const </span>{
<a name="l01154"></a>01154         <span class="keywordflow">return</span> m_Closure.IsLess(x.m_Closure);   }
<a name="l01155"></a>01155     <span class="keywordtype">bool</span> operator &gt;(<span class="keyword">const</span> fast_delegate3 &amp;x)<span class="keyword"> const </span>{
<a name="l01156"></a>01156         <span class="keywordflow">return</span> x.m_Closure.IsLess(m_Closure);   }
<a name="l01157"></a>01157     <span class="comment">// Binding to non-const member functions</span>
<a name="l01158"></a>01158     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01159"></a>01159     fast_delegate3(Y *pthis, result_type (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3) ) {
<a name="l01160"></a>01160         m_Closure.bindmemfunc(boost::idl::detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind); }
<a name="l01161"></a>01161     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01162"></a>01162     <span class="keyword">inline</span> <span class="keywordtype">void</span> bind(Y *pthis, result_type (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3)) {
<a name="l01163"></a>01163         m_Closure.bindmemfunc(boost::idl::detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind);  }
<a name="l01164"></a>01164     <span class="comment">// Binding to const member functions.</span>
<a name="l01165"></a>01165     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01166"></a>01166     fast_delegate3(<span class="keyword">const</span> Y *pthis, result_type (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3) <span class="keyword">const</span>) {
<a name="l01167"></a>01167         m_Closure.bindconstmemfunc(boost::idl::detail::implicit_cast&lt;const X*&gt;(pthis), function_to_bind);   }
<a name="l01168"></a>01168     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01169"></a>01169     <span class="keyword">inline</span> <span class="keywordtype">void</span> bind(<span class="keyword">const</span> Y *pthis, result_type (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3) <span class="keyword">const</span>) {
<a name="l01170"></a>01170         m_Closure.bindconstmemfunc(boost::idl::detail::implicit_cast&lt;const X *&gt;(pthis), function_to_bind);  }
<a name="l01171"></a>01171     <span class="comment">// Static functions. We convert them into a member function call.</span>
<a name="l01172"></a>01172     <span class="comment">// This constructor also provides implicit conversion</span>
<a name="l01173"></a>01173     fast_delegate3(result_type (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3) ) {
<a name="l01174"></a>01174         bind(function_to_bind); }
<a name="l01175"></a>01175     <span class="comment">// for efficiency, prevent creation of a temporary</span>
<a name="l01176"></a>01176     <span class="keywordtype">void</span> operator = (result_type (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3) ) {
<a name="l01177"></a>01177         bind(function_to_bind); }
<a name="l01178"></a>01178     <span class="keyword">inline</span> <span class="keywordtype">void</span> bind(result_type (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3)) {
<a name="l01179"></a>01179         m_Closure.bindstaticfunc(<span class="keyword">this</span>, &amp;fast_delegate3::InvokeStaticFunction, 
<a name="l01180"></a>01180             function_to_bind); }
<a name="l01181"></a>01181     <span class="comment">// Invoke the delegate</span>
<a name="l01182"></a>01182     RetType operator() (Param1 p1, Param2 p2, Param3 p3)<span class="keyword"> const </span>{
<a name="l01183"></a>01183     <span class="keywordflow">return</span> (m_Closure.GetClosureThis()-&gt;*(m_Closure.GetClosureMemPtr()))(p1, p2, p3); }
<a name="l01184"></a>01184     <span class="comment">// Implicit conversion to &quot;bool&quot; using the safe_bool idiom</span>
<a name="l01185"></a>01185 <span class="keyword">private</span>:
<a name="l01186"></a>01186     <span class="keyword">typedef</span> <span class="keyword">struct </span>SafeBoolStruct {
<a name="l01187"></a>01187         <span class="keywordtype">int</span> a_data_pointer_to_this_is_0_on_buggy_compilers;
<a name="l01188"></a>01188         StaticFunctionPtr m_nonzero;
<a name="l01189"></a>01189     } UselessTypedef;
<a name="l01190"></a>01190     <span class="keyword">typedef</span> StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
<a name="l01191"></a>01191 <span class="keyword">public</span>:
<a name="l01192"></a>01192     operator unspecified_bool_type()<span class="keyword"> const </span>{
<a name="l01193"></a>01193         <span class="keywordflow">return</span> empty()? 0: &amp;SafeBoolStruct::m_nonzero;
<a name="l01194"></a>01194     }
<a name="l01195"></a>01195     <span class="comment">// necessary to allow ==0 to work despite the safe_bool idiom</span>
<a name="l01196"></a>01196     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(StaticFunctionPtr funcptr) {
<a name="l01197"></a>01197         <span class="keywordflow">return</span> m_Closure.IsEqualToStaticFuncPtr(funcptr);   }
<a name="l01198"></a>01198     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator!=(StaticFunctionPtr funcptr) { 
<a name="l01199"></a>01199         <span class="keywordflow">return</span> !m_Closure.IsEqualToStaticFuncPtr(funcptr);    }
<a name="l01200"></a>01200     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator ! ()<span class="keyword"> const </span>{   <span class="comment">// Is it bound to anything?</span>
<a name="l01201"></a>01201             <span class="keywordflow">return</span> !m_Closure; }
<a name="l01202"></a>01202     <span class="keyword">inline</span> <span class="keywordtype">bool</span> empty()<span class="keyword"> const   </span>{
<a name="l01203"></a>01203             <span class="keywordflow">return</span> !m_Closure; }
<a name="l01204"></a>01204     <span class="keywordtype">void</span> clear() { m_Closure.clear();}
<a name="l01205"></a>01205     <span class="comment">// Conversion to and from the delegate_memento storage class</span>
<a name="l01206"></a>01206     <span class="keyword">const</span> delegate_memento &amp; get_memento()<span class="keyword">const </span>{ <span class="keywordflow">return</span> m_Closure; }
<a name="l01207"></a>01207     <span class="keywordtype">void</span> set_memento(<span class="keyword">const</span> delegate_memento &amp;any) { m_Closure.CopyFrom(<span class="keyword">this</span>, any); }
<a name="l01208"></a>01208 
<a name="l01209"></a>01209 <span class="keyword">private</span>:    <span class="comment">// Invoker for static functions</span>
<a name="l01210"></a>01210     RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3)<span class="keyword"> const </span>{
<a name="l01211"></a>01211     <span class="keywordflow">return</span> (*(m_Closure.GetStaticFunction()))(p1, p2, p3); }
<a name="l01212"></a>01212 };
<a name="l01213"></a>01213 
<a name="l01214"></a>01214 <span class="comment">//N=4</span>
<a name="l01215"></a>01215 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Param1, <span class="keyword">class</span> Param2, <span class="keyword">class</span> Param3, <span class="keyword">class</span> Param4, <span class="keyword">class</span> RetType=detail::DefaultVo<span class="keywordtype">id</span>&gt;
<a name="l01216"></a>01216 <span class="keyword">class </span>fast_delegate4 {
<a name="l01217"></a>01217 <span class="keyword">public</span>:
<a name="l01218"></a>01218     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::idl::detail::default_void_to_void&lt;RetType&gt;::type result_type;
<a name="l01219"></a>01219 <span class="keyword">private</span>:
<a name="l01220"></a>01220     <span class="keyword">typedef</span> result_type (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4);
<a name="l01221"></a>01221     <span class="keyword">typedef</span> RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4);
<a name="l01222"></a>01222     <span class="keyword">typedef</span> RetType (boost::idl::detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4);
<a name="l01223"></a>01223     <span class="keyword">typedef</span> boost::idl::detail::ClosurePtr&lt;GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr&gt; ClosureType;
<a name="l01224"></a>01224     ClosureType m_Closure;
<a name="l01225"></a>01225 <span class="keyword">public</span>:
<a name="l01226"></a>01226     <span class="comment">// Typedefs to aid generic programming</span>
<a name="l01227"></a>01227     <span class="keyword">typedef</span> fast_delegate4 type;
<a name="l01228"></a>01228 
<a name="l01229"></a>01229     <span class="comment">// Construction and comparison functions</span>
<a name="l01230"></a>01230     fast_delegate4() { clear(); }
<a name="l01231"></a>01231     fast_delegate4(<span class="keyword">const</span> fast_delegate4 &amp;x) {
<a name="l01232"></a>01232         m_Closure.CopyFrom(<span class="keyword">this</span>, x.m_Closure); }
<a name="l01233"></a>01233     <span class="keywordtype">void</span> operator = (<span class="keyword">const</span> fast_delegate4 &amp;x)  {
<a name="l01234"></a>01234         m_Closure.CopyFrom(<span class="keyword">this</span>, x.m_Closure); }
<a name="l01235"></a>01235     <span class="keywordtype">bool</span> operator ==(<span class="keyword">const</span> fast_delegate4 &amp;x)<span class="keyword"> const </span>{
<a name="l01236"></a>01236         <span class="keywordflow">return</span> m_Closure.IsEqual(x.m_Closure);  }
<a name="l01237"></a>01237     <span class="keywordtype">bool</span> operator !=(<span class="keyword">const</span> fast_delegate4 &amp;x)<span class="keyword"> const </span>{
<a name="l01238"></a>01238         <span class="keywordflow">return</span> !m_Closure.IsEqual(x.m_Closure); }
<a name="l01239"></a>01239     <span class="keywordtype">bool</span> operator &lt;(<span class="keyword">const</span> fast_delegate4 &amp;x)<span class="keyword"> const </span>{
<a name="l01240"></a>01240         <span class="keywordflow">return</span> m_Closure.IsLess(x.m_Closure);   }
<a name="l01241"></a>01241     <span class="keywordtype">bool</span> operator &gt;(<span class="keyword">const</span> fast_delegate4 &amp;x)<span class="keyword"> const </span>{
<a name="l01242"></a>01242         <span class="keywordflow">return</span> x.m_Closure.IsLess(m_Closure);   }
<a name="l01243"></a>01243     <span class="comment">// Binding to non-const member functions</span>
<a name="l01244"></a>01244     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01245"></a>01245     fast_delegate4(Y *pthis, result_type (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) ) {
<a name="l01246"></a>01246         m_Closure.bindmemfunc(boost::idl::detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind); }
<a name="l01247"></a>01247     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01248"></a>01248     <span class="keyword">inline</span> <span class="keywordtype">void</span> bind(Y *pthis, result_type (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4)) {
<a name="l01249"></a>01249         m_Closure.bindmemfunc(boost::idl::detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind);  }
<a name="l01250"></a>01250     <span class="comment">// Binding to const member functions.</span>
<a name="l01251"></a>01251     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01252"></a>01252     fast_delegate4(<span class="keyword">const</span> Y *pthis, result_type (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) <span class="keyword">const</span>) {
<a name="l01253"></a>01253         m_Closure.bindconstmemfunc(boost::idl::detail::implicit_cast&lt;const X*&gt;(pthis), function_to_bind);   }
<a name="l01254"></a>01254     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01255"></a>01255     <span class="keyword">inline</span> <span class="keywordtype">void</span> bind(<span class="keyword">const</span> Y *pthis, result_type (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) <span class="keyword">const</span>) {
<a name="l01256"></a>01256         m_Closure.bindconstmemfunc(boost::idl::detail::implicit_cast&lt;const X *&gt;(pthis), function_to_bind);  }
<a name="l01257"></a>01257     <span class="comment">// Static functions. We convert them into a member function call.</span>
<a name="l01258"></a>01258     <span class="comment">// This constructor also provides implicit conversion</span>
<a name="l01259"></a>01259     fast_delegate4(result_type (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) ) {
<a name="l01260"></a>01260         bind(function_to_bind); }
<a name="l01261"></a>01261     <span class="comment">// for efficiency, prevent creation of a temporary</span>
<a name="l01262"></a>01262     <span class="keywordtype">void</span> operator = (result_type (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) ) {
<a name="l01263"></a>01263         bind(function_to_bind); }
<a name="l01264"></a>01264     <span class="keyword">inline</span> <span class="keywordtype">void</span> bind(result_type (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4)) {
<a name="l01265"></a>01265         m_Closure.bindstaticfunc(<span class="keyword">this</span>, &amp;fast_delegate4::InvokeStaticFunction, 
<a name="l01266"></a>01266             function_to_bind); }
<a name="l01267"></a>01267     <span class="comment">// Invoke the delegate</span>
<a name="l01268"></a>01268     RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4)<span class="keyword"> const </span>{
<a name="l01269"></a>01269     <span class="keywordflow">return</span> (m_Closure.GetClosureThis()-&gt;*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4); }
<a name="l01270"></a>01270     <span class="comment">// Implicit conversion to &quot;bool&quot; using the safe_bool idiom</span>
<a name="l01271"></a>01271 <span class="keyword">private</span>:
<a name="l01272"></a>01272     <span class="keyword">typedef</span> <span class="keyword">struct </span>SafeBoolStruct {
<a name="l01273"></a>01273         <span class="keywordtype">int</span> a_data_pointer_to_this_is_0_on_buggy_compilers;
<a name="l01274"></a>01274         StaticFunctionPtr m_nonzero;
<a name="l01275"></a>01275     } UselessTypedef;
<a name="l01276"></a>01276     <span class="keyword">typedef</span> StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
<a name="l01277"></a>01277 <span class="keyword">public</span>:
<a name="l01278"></a>01278     operator unspecified_bool_type()<span class="keyword"> const </span>{
<a name="l01279"></a>01279         <span class="keywordflow">return</span> empty()? 0: &amp;SafeBoolStruct::m_nonzero;
<a name="l01280"></a>01280     }
<a name="l01281"></a>01281     <span class="comment">// necessary to allow ==0 to work despite the safe_bool idiom</span>
<a name="l01282"></a>01282     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(StaticFunctionPtr funcptr) {
<a name="l01283"></a>01283         <span class="keywordflow">return</span> m_Closure.IsEqualToStaticFuncPtr(funcptr);   }
<a name="l01284"></a>01284     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator!=(StaticFunctionPtr funcptr) { 
<a name="l01285"></a>01285         <span class="keywordflow">return</span> !m_Closure.IsEqualToStaticFuncPtr(funcptr);    }
<a name="l01286"></a>01286     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator ! ()<span class="keyword"> const </span>{   <span class="comment">// Is it bound to anything?</span>
<a name="l01287"></a>01287             <span class="keywordflow">return</span> !m_Closure; }
<a name="l01288"></a>01288     <span class="keyword">inline</span> <span class="keywordtype">bool</span> empty()<span class="keyword"> const   </span>{
<a name="l01289"></a>01289             <span class="keywordflow">return</span> !m_Closure; }
<a name="l01290"></a>01290     <span class="keywordtype">void</span> clear() { m_Closure.clear();}
<a name="l01291"></a>01291     <span class="comment">// Conversion to and from the delegate_memento storage class</span>
<a name="l01292"></a>01292     <span class="keyword">const</span> delegate_memento &amp; get_memento()<span class="keyword">const </span>{ <span class="keywordflow">return</span> m_Closure; }
<a name="l01293"></a>01293     <span class="keywordtype">void</span> set_memento(<span class="keyword">const</span> delegate_memento &amp;any) { m_Closure.CopyFrom(<span class="keyword">this</span>, any); }
<a name="l01294"></a>01294 
<a name="l01295"></a>01295 <span class="keyword">private</span>:    <span class="comment">// Invoker for static functions</span>
<a name="l01296"></a>01296     RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4)<span class="keyword"> const </span>{
<a name="l01297"></a>01297     <span class="keywordflow">return</span> (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4); }
<a name="l01298"></a>01298 };
<a name="l01299"></a>01299 
<a name="l01300"></a>01300 <span class="comment">//N=5</span>
<a name="l01301"></a>01301 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Param1, <span class="keyword">class</span> Param2, <span class="keyword">class</span> Param3, <span class="keyword">class</span> Param4, <span class="keyword">class</span> Param5, <span class="keyword">class</span> RetType=detail::DefaultVo<span class="keywordtype">id</span>&gt;
<a name="l01302"></a>01302 <span class="keyword">class </span>fast_delegate5 {
<a name="l01303"></a>01303 <span class="keyword">public</span>:
<a name="l01304"></a>01304     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::idl::detail::default_void_to_void&lt;RetType&gt;::type result_type;
<a name="l01305"></a>01305 <span class="keyword">private</span>:
<a name="l01306"></a>01306     <span class="keyword">typedef</span> result_type (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5);
<a name="l01307"></a>01307     <span class="keyword">typedef</span> RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5);
<a name="l01308"></a>01308     <span class="keyword">typedef</span> RetType (boost::idl::detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5);
<a name="l01309"></a>01309     <span class="keyword">typedef</span> boost::idl::detail::ClosurePtr&lt;GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr&gt; ClosureType;
<a name="l01310"></a>01310     ClosureType m_Closure;
<a name="l01311"></a>01311 <span class="keyword">public</span>:
<a name="l01312"></a>01312     <span class="comment">// Typedefs to aid generic programming</span>
<a name="l01313"></a>01313     <span class="keyword">typedef</span> fast_delegate5 type;
<a name="l01314"></a>01314 
<a name="l01315"></a>01315     <span class="comment">// Construction and comparison functions</span>
<a name="l01316"></a>01316     fast_delegate5() { clear(); }
<a name="l01317"></a>01317     fast_delegate5(<span class="keyword">const</span> fast_delegate5 &amp;x) {
<a name="l01318"></a>01318         m_Closure.CopyFrom(<span class="keyword">this</span>, x.m_Closure); }
<a name="l01319"></a>01319     <span class="keywordtype">void</span> operator = (<span class="keyword">const</span> fast_delegate5 &amp;x)  {
<a name="l01320"></a>01320         m_Closure.CopyFrom(<span class="keyword">this</span>, x.m_Closure); }
<a name="l01321"></a>01321     <span class="keywordtype">bool</span> operator ==(<span class="keyword">const</span> fast_delegate5 &amp;x)<span class="keyword"> const </span>{
<a name="l01322"></a>01322         <span class="keywordflow">return</span> m_Closure.IsEqual(x.m_Closure);  }
<a name="l01323"></a>01323     <span class="keywordtype">bool</span> operator !=(<span class="keyword">const</span> fast_delegate5 &amp;x)<span class="keyword"> const </span>{
<a name="l01324"></a>01324         <span class="keywordflow">return</span> !m_Closure.IsEqual(x.m_Closure); }
<a name="l01325"></a>01325     <span class="keywordtype">bool</span> operator &lt;(<span class="keyword">const</span> fast_delegate5 &amp;x)<span class="keyword"> const </span>{
<a name="l01326"></a>01326         <span class="keywordflow">return</span> m_Closure.IsLess(x.m_Closure);   }
<a name="l01327"></a>01327     <span class="keywordtype">bool</span> operator &gt;(<span class="keyword">const</span> fast_delegate5 &amp;x)<span class="keyword"> const </span>{
<a name="l01328"></a>01328         <span class="keywordflow">return</span> x.m_Closure.IsLess(m_Closure);   }
<a name="l01329"></a>01329     <span class="comment">// Binding to non-const member functions</span>
<a name="l01330"></a>01330     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01331"></a>01331     fast_delegate5(Y *pthis, result_type (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) ) {
<a name="l01332"></a>01332         m_Closure.bindmemfunc(boost::idl::detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind); }
<a name="l01333"></a>01333     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01334"></a>01334     <span class="keyword">inline</span> <span class="keywordtype">void</span> bind(Y *pthis, result_type (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5)) {
<a name="l01335"></a>01335         m_Closure.bindmemfunc(boost::idl::detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind);  }
<a name="l01336"></a>01336     <span class="comment">// Binding to const member functions.</span>
<a name="l01337"></a>01337     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01338"></a>01338     fast_delegate5(<span class="keyword">const</span> Y *pthis, result_type (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) <span class="keyword">const</span>) {
<a name="l01339"></a>01339         m_Closure.bindconstmemfunc(boost::idl::detail::implicit_cast&lt;const X*&gt;(pthis), function_to_bind);   }
<a name="l01340"></a>01340     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01341"></a>01341     <span class="keyword">inline</span> <span class="keywordtype">void</span> bind(<span class="keyword">const</span> Y *pthis, result_type (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) <span class="keyword">const</span>) {
<a name="l01342"></a>01342         m_Closure.bindconstmemfunc(boost::idl::detail::implicit_cast&lt;const X *&gt;(pthis), function_to_bind);  }
<a name="l01343"></a>01343     <span class="comment">// Static functions. We convert them into a member function call.</span>
<a name="l01344"></a>01344     <span class="comment">// This constructor also provides implicit conversion</span>
<a name="l01345"></a>01345     fast_delegate5(result_type (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) ) {
<a name="l01346"></a>01346         bind(function_to_bind); }
<a name="l01347"></a>01347     <span class="comment">// for efficiency, prevent creation of a temporary</span>
<a name="l01348"></a>01348     <span class="keywordtype">void</span> operator = (result_type (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) ) {
<a name="l01349"></a>01349         bind(function_to_bind); }
<a name="l01350"></a>01350     <span class="keyword">inline</span> <span class="keywordtype">void</span> bind(result_type (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5)) {
<a name="l01351"></a>01351         m_Closure.bindstaticfunc(<span class="keyword">this</span>, &amp;fast_delegate5::InvokeStaticFunction, 
<a name="l01352"></a>01352             function_to_bind); }
<a name="l01353"></a>01353     <span class="comment">// Invoke the delegate</span>
<a name="l01354"></a>01354     RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5)<span class="keyword"> const </span>{
<a name="l01355"></a>01355     <span class="keywordflow">return</span> (m_Closure.GetClosureThis()-&gt;*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5); }
<a name="l01356"></a>01356     <span class="comment">// Implicit conversion to &quot;bool&quot; using the safe_bool idiom</span>
<a name="l01357"></a>01357 <span class="keyword">private</span>:
<a name="l01358"></a>01358     <span class="keyword">typedef</span> <span class="keyword">struct </span>SafeBoolStruct {
<a name="l01359"></a>01359         <span class="keywordtype">int</span> a_data_pointer_to_this_is_0_on_buggy_compilers;
<a name="l01360"></a>01360         StaticFunctionPtr m_nonzero;
<a name="l01361"></a>01361     } UselessTypedef;
<a name="l01362"></a>01362     <span class="keyword">typedef</span> StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
<a name="l01363"></a>01363 <span class="keyword">public</span>:
<a name="l01364"></a>01364     operator unspecified_bool_type()<span class="keyword"> const </span>{
<a name="l01365"></a>01365         <span class="keywordflow">return</span> empty()? 0: &amp;SafeBoolStruct::m_nonzero;
<a name="l01366"></a>01366     }
<a name="l01367"></a>01367     <span class="comment">// necessary to allow ==0 to work despite the safe_bool idiom</span>
<a name="l01368"></a>01368     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(StaticFunctionPtr funcptr) {
<a name="l01369"></a>01369         <span class="keywordflow">return</span> m_Closure.IsEqualToStaticFuncPtr(funcptr);   }
<a name="l01370"></a>01370     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator!=(StaticFunctionPtr funcptr) { 
<a name="l01371"></a>01371         <span class="keywordflow">return</span> !m_Closure.IsEqualToStaticFuncPtr(funcptr);    }
<a name="l01372"></a>01372     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator ! ()<span class="keyword"> const </span>{   <span class="comment">// Is it bound to anything?</span>
<a name="l01373"></a>01373             <span class="keywordflow">return</span> !m_Closure; }
<a name="l01374"></a>01374     <span class="keyword">inline</span> <span class="keywordtype">bool</span> empty()<span class="keyword"> const   </span>{
<a name="l01375"></a>01375             <span class="keywordflow">return</span> !m_Closure; }
<a name="l01376"></a>01376     <span class="keywordtype">void</span> clear() { m_Closure.clear();}
<a name="l01377"></a>01377     <span class="comment">// Conversion to and from the delegate_memento storage class</span>
<a name="l01378"></a>01378     <span class="keyword">const</span> delegate_memento &amp; get_memento()<span class="keyword">const </span>{ <span class="keywordflow">return</span> m_Closure; }
<a name="l01379"></a>01379     <span class="keywordtype">void</span> set_memento(<span class="keyword">const</span> delegate_memento &amp;any) { m_Closure.CopyFrom(<span class="keyword">this</span>, any); }
<a name="l01380"></a>01380 
<a name="l01381"></a>01381 <span class="keyword">private</span>:    <span class="comment">// Invoker for static functions</span>
<a name="l01382"></a>01382     RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5)<span class="keyword"> const </span>{
<a name="l01383"></a>01383     <span class="keywordflow">return</span> (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5); }
<a name="l01384"></a>01384 };
<a name="l01385"></a>01385 
<a name="l01386"></a>01386 <span class="comment">//N=6</span>
<a name="l01387"></a>01387 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Param1, <span class="keyword">class</span> Param2, <span class="keyword">class</span> Param3, <span class="keyword">class</span> Param4, <span class="keyword">class</span> Param5, <span class="keyword">class</span> Param6, <span class="keyword">class</span> RetType=detail::DefaultVo<span class="keywordtype">id</span>&gt;
<a name="l01388"></a>01388 <span class="keyword">class </span>fast_delegate6 {
<a name="l01389"></a>01389 <span class="keyword">public</span>:
<a name="l01390"></a>01390     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::idl::detail::default_void_to_void&lt;RetType&gt;::type result_type;
<a name="l01391"></a>01391 <span class="keyword">private</span>:
<a name="l01392"></a>01392     <span class="keyword">typedef</span> result_type (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6);
<a name="l01393"></a>01393     <span class="keyword">typedef</span> RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6);
<a name="l01394"></a>01394     <span class="keyword">typedef</span> RetType (boost::idl::detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6);
<a name="l01395"></a>01395     <span class="keyword">typedef</span> boost::idl::detail::ClosurePtr&lt;GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr&gt; ClosureType;
<a name="l01396"></a>01396     ClosureType m_Closure;
<a name="l01397"></a>01397 <span class="keyword">public</span>:
<a name="l01398"></a>01398     <span class="comment">// Typedefs to aid generic programming</span>
<a name="l01399"></a>01399     <span class="keyword">typedef</span> fast_delegate6 type;
<a name="l01400"></a>01400 
<a name="l01401"></a>01401     <span class="comment">// Construction and comparison functions</span>
<a name="l01402"></a>01402     fast_delegate6() { clear(); }
<a name="l01403"></a>01403     fast_delegate6(<span class="keyword">const</span> fast_delegate6 &amp;x) {
<a name="l01404"></a>01404         m_Closure.CopyFrom(<span class="keyword">this</span>, x.m_Closure); }
<a name="l01405"></a>01405     <span class="keywordtype">void</span> operator = (<span class="keyword">const</span> fast_delegate6 &amp;x)  {
<a name="l01406"></a>01406         m_Closure.CopyFrom(<span class="keyword">this</span>, x.m_Closure); }
<a name="l01407"></a>01407     <span class="keywordtype">bool</span> operator ==(<span class="keyword">const</span> fast_delegate6 &amp;x)<span class="keyword"> const </span>{
<a name="l01408"></a>01408         <span class="keywordflow">return</span> m_Closure.IsEqual(x.m_Closure);  }
<a name="l01409"></a>01409     <span class="keywordtype">bool</span> operator !=(<span class="keyword">const</span> fast_delegate6 &amp;x)<span class="keyword"> const </span>{
<a name="l01410"></a>01410         <span class="keywordflow">return</span> !m_Closure.IsEqual(x.m_Closure); }
<a name="l01411"></a>01411     <span class="keywordtype">bool</span> operator &lt;(<span class="keyword">const</span> fast_delegate6 &amp;x)<span class="keyword"> const </span>{
<a name="l01412"></a>01412         <span class="keywordflow">return</span> m_Closure.IsLess(x.m_Closure);   }
<a name="l01413"></a>01413     <span class="keywordtype">bool</span> operator &gt;(<span class="keyword">const</span> fast_delegate6 &amp;x)<span class="keyword"> const </span>{
<a name="l01414"></a>01414         <span class="keywordflow">return</span> x.m_Closure.IsLess(m_Closure);   }
<a name="l01415"></a>01415     <span class="comment">// Binding to non-const member functions</span>
<a name="l01416"></a>01416     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01417"></a>01417     fast_delegate6(Y *pthis, result_type (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) ) {
<a name="l01418"></a>01418         m_Closure.bindmemfunc(boost::idl::detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind); }
<a name="l01419"></a>01419     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01420"></a>01420     <span class="keyword">inline</span> <span class="keywordtype">void</span> bind(Y *pthis, result_type (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6)) {
<a name="l01421"></a>01421         m_Closure.bindmemfunc(boost::idl::detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind);  }
<a name="l01422"></a>01422     <span class="comment">// Binding to const member functions.</span>
<a name="l01423"></a>01423     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01424"></a>01424     fast_delegate6(<span class="keyword">const</span> Y *pthis, result_type (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) <span class="keyword">const</span>) {
<a name="l01425"></a>01425         m_Closure.bindconstmemfunc(boost::idl::detail::implicit_cast&lt;const X*&gt;(pthis), function_to_bind);   }
<a name="l01426"></a>01426     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01427"></a>01427     <span class="keyword">inline</span> <span class="keywordtype">void</span> bind(<span class="keyword">const</span> Y *pthis, result_type (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) <span class="keyword">const</span>) {
<a name="l01428"></a>01428         m_Closure.bindconstmemfunc(boost::idl::detail::implicit_cast&lt;const X *&gt;(pthis), function_to_bind);  }
<a name="l01429"></a>01429     <span class="comment">// Static functions. We convert them into a member function call.</span>
<a name="l01430"></a>01430     <span class="comment">// This constructor also provides implicit conversion</span>
<a name="l01431"></a>01431     fast_delegate6(result_type (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) ) {
<a name="l01432"></a>01432         bind(function_to_bind); }
<a name="l01433"></a>01433     <span class="comment">// for efficiency, prevent creation of a temporary</span>
<a name="l01434"></a>01434     <span class="keywordtype">void</span> operator = (result_type (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) ) {
<a name="l01435"></a>01435         bind(function_to_bind); }
<a name="l01436"></a>01436     <span class="keyword">inline</span> <span class="keywordtype">void</span> bind(result_type (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6)) {
<a name="l01437"></a>01437         m_Closure.bindstaticfunc(<span class="keyword">this</span>, &amp;fast_delegate6::InvokeStaticFunction, 
<a name="l01438"></a>01438             function_to_bind); }
<a name="l01439"></a>01439     <span class="comment">// Invoke the delegate</span>
<a name="l01440"></a>01440     RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6)<span class="keyword"> const </span>{
<a name="l01441"></a>01441     <span class="keywordflow">return</span> (m_Closure.GetClosureThis()-&gt;*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6); }
<a name="l01442"></a>01442     <span class="comment">// Implicit conversion to &quot;bool&quot; using the safe_bool idiom</span>
<a name="l01443"></a>01443 <span class="keyword">private</span>:
<a name="l01444"></a>01444     <span class="keyword">typedef</span> <span class="keyword">struct </span>SafeBoolStruct {
<a name="l01445"></a>01445         <span class="keywordtype">int</span> a_data_pointer_to_this_is_0_on_buggy_compilers;
<a name="l01446"></a>01446         StaticFunctionPtr m_nonzero;
<a name="l01447"></a>01447     } UselessTypedef;
<a name="l01448"></a>01448     <span class="keyword">typedef</span> StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
<a name="l01449"></a>01449 <span class="keyword">public</span>:
<a name="l01450"></a>01450     operator unspecified_bool_type()<span class="keyword"> const </span>{
<a name="l01451"></a>01451         <span class="keywordflow">return</span> empty()? 0: &amp;SafeBoolStruct::m_nonzero;
<a name="l01452"></a>01452     }
<a name="l01453"></a>01453     <span class="comment">// necessary to allow ==0 to work despite the safe_bool idiom</span>
<a name="l01454"></a>01454     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(StaticFunctionPtr funcptr) {
<a name="l01455"></a>01455         <span class="keywordflow">return</span> m_Closure.IsEqualToStaticFuncPtr(funcptr);   }
<a name="l01456"></a>01456     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator!=(StaticFunctionPtr funcptr) { 
<a name="l01457"></a>01457         <span class="keywordflow">return</span> !m_Closure.IsEqualToStaticFuncPtr(funcptr);    }
<a name="l01458"></a>01458     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator ! ()<span class="keyword"> const </span>{   <span class="comment">// Is it bound to anything?</span>
<a name="l01459"></a>01459             <span class="keywordflow">return</span> !m_Closure; }
<a name="l01460"></a>01460     <span class="keyword">inline</span> <span class="keywordtype">bool</span> empty()<span class="keyword"> const   </span>{
<a name="l01461"></a>01461             <span class="keywordflow">return</span> !m_Closure; }
<a name="l01462"></a>01462     <span class="keywordtype">void</span> clear() { m_Closure.clear();}
<a name="l01463"></a>01463     <span class="comment">// Conversion to and from the delegate_memento storage class</span>
<a name="l01464"></a>01464     <span class="keyword">const</span> delegate_memento &amp; get_memento()<span class="keyword">const </span>{ <span class="keywordflow">return</span> m_Closure; }
<a name="l01465"></a>01465     <span class="keywordtype">void</span> set_memento(<span class="keyword">const</span> delegate_memento &amp;any) { m_Closure.CopyFrom(<span class="keyword">this</span>, any); }
<a name="l01466"></a>01466 
<a name="l01467"></a>01467 <span class="keyword">private</span>:    <span class="comment">// Invoker for static functions</span>
<a name="l01468"></a>01468     RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6)<span class="keyword"> const </span>{
<a name="l01469"></a>01469     <span class="keywordflow">return</span> (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6); }
<a name="l01470"></a>01470 };
<a name="l01471"></a>01471 
<a name="l01472"></a>01472 <span class="comment">//N=7</span>
<a name="l01473"></a>01473 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Param1, <span class="keyword">class</span> Param2, <span class="keyword">class</span> Param3, <span class="keyword">class</span> Param4, <span class="keyword">class</span> Param5, <span class="keyword">class</span> Param6, <span class="keyword">class</span> Param7, <span class="keyword">class</span> RetType=detail::DefaultVo<span class="keywordtype">id</span>&gt;
<a name="l01474"></a>01474 <span class="keyword">class </span>fast_delegate7 {
<a name="l01475"></a>01475 <span class="keyword">public</span>:
<a name="l01476"></a>01476     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::idl::detail::default_void_to_void&lt;RetType&gt;::type result_type;
<a name="l01477"></a>01477 <span class="keyword">private</span>:
<a name="l01478"></a>01478     <span class="keyword">typedef</span> result_type (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7);
<a name="l01479"></a>01479     <span class="keyword">typedef</span> RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7);
<a name="l01480"></a>01480     <span class="keyword">typedef</span> RetType (boost::idl::detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7);
<a name="l01481"></a>01481     <span class="keyword">typedef</span> boost::idl::detail::ClosurePtr&lt;GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr&gt; ClosureType;
<a name="l01482"></a>01482     ClosureType m_Closure;
<a name="l01483"></a>01483 <span class="keyword">public</span>:
<a name="l01484"></a>01484     <span class="comment">// Typedefs to aid generic programming</span>
<a name="l01485"></a>01485     <span class="keyword">typedef</span> fast_delegate7 type;
<a name="l01486"></a>01486 
<a name="l01487"></a>01487     <span class="comment">// Construction and comparison functions</span>
<a name="l01488"></a>01488     fast_delegate7() { clear(); }
<a name="l01489"></a>01489     fast_delegate7(<span class="keyword">const</span> fast_delegate7 &amp;x) {
<a name="l01490"></a>01490         m_Closure.CopyFrom(<span class="keyword">this</span>, x.m_Closure); }
<a name="l01491"></a>01491     <span class="keywordtype">void</span> operator = (<span class="keyword">const</span> fast_delegate7 &amp;x)  {
<a name="l01492"></a>01492         m_Closure.CopyFrom(<span class="keyword">this</span>, x.m_Closure); }
<a name="l01493"></a>01493     <span class="keywordtype">bool</span> operator ==(<span class="keyword">const</span> fast_delegate7 &amp;x)<span class="keyword"> const </span>{
<a name="l01494"></a>01494         <span class="keywordflow">return</span> m_Closure.IsEqual(x.m_Closure);  }
<a name="l01495"></a>01495     <span class="keywordtype">bool</span> operator !=(<span class="keyword">const</span> fast_delegate7 &amp;x)<span class="keyword"> const </span>{
<a name="l01496"></a>01496         <span class="keywordflow">return</span> !m_Closure.IsEqual(x.m_Closure); }
<a name="l01497"></a>01497     <span class="keywordtype">bool</span> operator &lt;(<span class="keyword">const</span> fast_delegate7 &amp;x)<span class="keyword"> const </span>{
<a name="l01498"></a>01498         <span class="keywordflow">return</span> m_Closure.IsLess(x.m_Closure);   }
<a name="l01499"></a>01499     <span class="keywordtype">bool</span> operator &gt;(<span class="keyword">const</span> fast_delegate7 &amp;x)<span class="keyword"> const </span>{
<a name="l01500"></a>01500         <span class="keywordflow">return</span> x.m_Closure.IsLess(m_Closure);   }
<a name="l01501"></a>01501     <span class="comment">// Binding to non-const member functions</span>
<a name="l01502"></a>01502     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01503"></a>01503     fast_delegate7(Y *pthis, result_type (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) ) {
<a name="l01504"></a>01504         m_Closure.bindmemfunc(boost::idl::detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind); }
<a name="l01505"></a>01505     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01506"></a>01506     <span class="keyword">inline</span> <span class="keywordtype">void</span> bind(Y *pthis, result_type (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7)) {
<a name="l01507"></a>01507         m_Closure.bindmemfunc(boost::idl::detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind);  }
<a name="l01508"></a>01508     <span class="comment">// Binding to const member functions.</span>
<a name="l01509"></a>01509     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01510"></a>01510     fast_delegate7(<span class="keyword">const</span> Y *pthis, result_type (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) <span class="keyword">const</span>) {
<a name="l01511"></a>01511         m_Closure.bindconstmemfunc(boost::idl::detail::implicit_cast&lt;const X*&gt;(pthis), function_to_bind);   }
<a name="l01512"></a>01512     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01513"></a>01513     <span class="keyword">inline</span> <span class="keywordtype">void</span> bind(<span class="keyword">const</span> Y *pthis, result_type (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) <span class="keyword">const</span>) {
<a name="l01514"></a>01514         m_Closure.bindconstmemfunc(boost::idl::detail::implicit_cast&lt;const X *&gt;(pthis), function_to_bind);  }
<a name="l01515"></a>01515     <span class="comment">// Static functions. We convert them into a member function call.</span>
<a name="l01516"></a>01516     <span class="comment">// This constructor also provides implicit conversion</span>
<a name="l01517"></a>01517     fast_delegate7(result_type (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) ) {
<a name="l01518"></a>01518         bind(function_to_bind); }
<a name="l01519"></a>01519     <span class="comment">// for efficiency, prevent creation of a temporary</span>
<a name="l01520"></a>01520     <span class="keywordtype">void</span> operator = (result_type (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) ) {
<a name="l01521"></a>01521         bind(function_to_bind); }
<a name="l01522"></a>01522     <span class="keyword">inline</span> <span class="keywordtype">void</span> bind(result_type (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7)) {
<a name="l01523"></a>01523         m_Closure.bindstaticfunc(<span class="keyword">this</span>, &amp;fast_delegate7::InvokeStaticFunction, 
<a name="l01524"></a>01524             function_to_bind); }
<a name="l01525"></a>01525     <span class="comment">// Invoke the delegate</span>
<a name="l01526"></a>01526     RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7)<span class="keyword"> const </span>{
<a name="l01527"></a>01527     <span class="keywordflow">return</span> (m_Closure.GetClosureThis()-&gt;*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6, p7); }
<a name="l01528"></a>01528     <span class="comment">// Implicit conversion to &quot;bool&quot; using the safe_bool idiom</span>
<a name="l01529"></a>01529 <span class="keyword">private</span>:
<a name="l01530"></a>01530     <span class="keyword">typedef</span> <span class="keyword">struct </span>SafeBoolStruct {
<a name="l01531"></a>01531         <span class="keywordtype">int</span> a_data_pointer_to_this_is_0_on_buggy_compilers;
<a name="l01532"></a>01532         StaticFunctionPtr m_nonzero;
<a name="l01533"></a>01533     } UselessTypedef;
<a name="l01534"></a>01534     <span class="keyword">typedef</span> StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
<a name="l01535"></a>01535 <span class="keyword">public</span>:
<a name="l01536"></a>01536     operator unspecified_bool_type()<span class="keyword"> const </span>{
<a name="l01537"></a>01537         <span class="keywordflow">return</span> empty()? 0: &amp;SafeBoolStruct::m_nonzero;
<a name="l01538"></a>01538     }
<a name="l01539"></a>01539     <span class="comment">// necessary to allow ==0 to work despite the safe_bool idiom</span>
<a name="l01540"></a>01540     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(StaticFunctionPtr funcptr) {
<a name="l01541"></a>01541         <span class="keywordflow">return</span> m_Closure.IsEqualToStaticFuncPtr(funcptr);   }
<a name="l01542"></a>01542     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator!=(StaticFunctionPtr funcptr) { 
<a name="l01543"></a>01543         <span class="keywordflow">return</span> !m_Closure.IsEqualToStaticFuncPtr(funcptr);    }
<a name="l01544"></a>01544     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator ! ()<span class="keyword"> const </span>{   <span class="comment">// Is it bound to anything?</span>
<a name="l01545"></a>01545             <span class="keywordflow">return</span> !m_Closure; }
<a name="l01546"></a>01546     <span class="keyword">inline</span> <span class="keywordtype">bool</span> empty()<span class="keyword"> const   </span>{
<a name="l01547"></a>01547             <span class="keywordflow">return</span> !m_Closure; }
<a name="l01548"></a>01548     <span class="keywordtype">void</span> clear() { m_Closure.clear();}
<a name="l01549"></a>01549     <span class="comment">// Conversion to and from the delegate_memento storage class</span>
<a name="l01550"></a>01550     <span class="keyword">const</span> delegate_memento &amp; get_memento()<span class="keyword">const </span>{ <span class="keywordflow">return</span> m_Closure; }
<a name="l01551"></a>01551     <span class="keywordtype">void</span> set_memento(<span class="keyword">const</span> delegate_memento &amp;any) { m_Closure.CopyFrom(<span class="keyword">this</span>, any); }
<a name="l01552"></a>01552 
<a name="l01553"></a>01553 <span class="keyword">private</span>:    <span class="comment">// Invoker for static functions</span>
<a name="l01554"></a>01554     RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7)<span class="keyword"> const </span>{
<a name="l01555"></a>01555     <span class="keywordflow">return</span> (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6, p7); }
<a name="l01556"></a>01556 };
<a name="l01557"></a>01557 
<a name="l01558"></a>01558 <span class="comment">//N=8</span>
<a name="l01559"></a>01559 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Param1, <span class="keyword">class</span> Param2, <span class="keyword">class</span> Param3, <span class="keyword">class</span> Param4, <span class="keyword">class</span> Param5, <span class="keyword">class</span> Param6, <span class="keyword">class</span> Param7, <span class="keyword">class</span> Param8, <span class="keyword">class</span> RetType=detail::DefaultVo<span class="keywordtype">id</span>&gt;
<a name="l01560"></a>01560 <span class="keyword">class </span>fast_delegate8 {
<a name="l01561"></a>01561 <span class="keyword">public</span>:
<a name="l01562"></a>01562     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::idl::detail::default_void_to_void&lt;RetType&gt;::type result_type;
<a name="l01563"></a>01563 <span class="keyword">private</span>:
<a name="l01564"></a>01564     <span class="keyword">typedef</span> result_type (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8);
<a name="l01565"></a>01565     <span class="keyword">typedef</span> RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8);
<a name="l01566"></a>01566     <span class="keyword">typedef</span> RetType (boost::idl::detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8);
<a name="l01567"></a>01567     <span class="keyword">typedef</span> boost::idl::detail::ClosurePtr&lt;GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr&gt; ClosureType;
<a name="l01568"></a>01568     ClosureType m_Closure;
<a name="l01569"></a>01569 <span class="keyword">public</span>:
<a name="l01570"></a>01570     <span class="comment">// Typedefs to aid generic programming</span>
<a name="l01571"></a>01571     <span class="keyword">typedef</span> fast_delegate8 type;
<a name="l01572"></a>01572 
<a name="l01573"></a>01573     <span class="comment">// Construction and comparison functions</span>
<a name="l01574"></a>01574     fast_delegate8() { clear(); }
<a name="l01575"></a>01575     fast_delegate8(<span class="keyword">const</span> fast_delegate8 &amp;x) {
<a name="l01576"></a>01576         m_Closure.CopyFrom(<span class="keyword">this</span>, x.m_Closure); }
<a name="l01577"></a>01577     <span class="keywordtype">void</span> operator = (<span class="keyword">const</span> fast_delegate8 &amp;x)  {
<a name="l01578"></a>01578         m_Closure.CopyFrom(<span class="keyword">this</span>, x.m_Closure); }
<a name="l01579"></a>01579     <span class="keywordtype">bool</span> operator ==(<span class="keyword">const</span> fast_delegate8 &amp;x)<span class="keyword"> const </span>{
<a name="l01580"></a>01580         <span class="keywordflow">return</span> m_Closure.IsEqual(x.m_Closure);  }
<a name="l01581"></a>01581     <span class="keywordtype">bool</span> operator !=(<span class="keyword">const</span> fast_delegate8 &amp;x)<span class="keyword"> const </span>{
<a name="l01582"></a>01582         <span class="keywordflow">return</span> !m_Closure.IsEqual(x.m_Closure); }
<a name="l01583"></a>01583     <span class="keywordtype">bool</span> operator &lt;(<span class="keyword">const</span> fast_delegate8 &amp;x)<span class="keyword"> const </span>{
<a name="l01584"></a>01584         <span class="keywordflow">return</span> m_Closure.IsLess(x.m_Closure);   }
<a name="l01585"></a>01585     <span class="keywordtype">bool</span> operator &gt;(<span class="keyword">const</span> fast_delegate8 &amp;x)<span class="keyword"> const </span>{
<a name="l01586"></a>01586         <span class="keywordflow">return</span> x.m_Closure.IsLess(m_Closure);   }
<a name="l01587"></a>01587     <span class="comment">// Binding to non-const member functions</span>
<a name="l01588"></a>01588     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01589"></a>01589     fast_delegate8(Y *pthis, result_type (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) ) {
<a name="l01590"></a>01590         m_Closure.bindmemfunc(boost::idl::detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind); }
<a name="l01591"></a>01591     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01592"></a>01592     <span class="keyword">inline</span> <span class="keywordtype">void</span> bind(Y *pthis, result_type (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8)) {
<a name="l01593"></a>01593         m_Closure.bindmemfunc(boost::idl::detail::implicit_cast&lt;X*&gt;(pthis), function_to_bind);  }
<a name="l01594"></a>01594     <span class="comment">// Binding to const member functions.</span>
<a name="l01595"></a>01595     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01596"></a>01596     fast_delegate8(<span class="keyword">const</span> Y *pthis, result_type (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) <span class="keyword">const</span>) {
<a name="l01597"></a>01597         m_Closure.bindconstmemfunc(boost::idl::detail::implicit_cast&lt;const X*&gt;(pthis), function_to_bind);   }
<a name="l01598"></a>01598     <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01599"></a>01599     <span class="keyword">inline</span> <span class="keywordtype">void</span> bind(<span class="keyword">const</span> Y *pthis, result_type (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) <span class="keyword">const</span>) {
<a name="l01600"></a>01600         m_Closure.bindconstmemfunc(boost::idl::detail::implicit_cast&lt;const X *&gt;(pthis), function_to_bind);  }
<a name="l01601"></a>01601     <span class="comment">// Static functions. We convert them into a member function call.</span>
<a name="l01602"></a>01602     <span class="comment">// This constructor also provides implicit conversion</span>
<a name="l01603"></a>01603     fast_delegate8(result_type (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) ) {
<a name="l01604"></a>01604         bind(function_to_bind); }
<a name="l01605"></a>01605     <span class="comment">// for efficiency, prevent creation of a temporary</span>
<a name="l01606"></a>01606     <span class="keywordtype">void</span> operator = (result_type (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) ) {
<a name="l01607"></a>01607         bind(function_to_bind); }
<a name="l01608"></a>01608     <span class="keyword">inline</span> <span class="keywordtype">void</span> bind(result_type (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8)) {
<a name="l01609"></a>01609         m_Closure.bindstaticfunc(<span class="keyword">this</span>, &amp;fast_delegate8::InvokeStaticFunction, 
<a name="l01610"></a>01610             function_to_bind); }
<a name="l01611"></a>01611     <span class="comment">// Invoke the delegate</span>
<a name="l01612"></a>01612     RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8)<span class="keyword"> const </span>{
<a name="l01613"></a>01613     <span class="keywordflow">return</span> (m_Closure.GetClosureThis()-&gt;*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6, p7, p8); }
<a name="l01614"></a>01614     <span class="comment">// Implicit conversion to &quot;bool&quot; using the safe_bool idiom</span>
<a name="l01615"></a>01615 <span class="keyword">private</span>:
<a name="l01616"></a>01616     <span class="keyword">typedef</span> <span class="keyword">struct </span>SafeBoolStruct {
<a name="l01617"></a>01617         <span class="keywordtype">int</span> a_data_pointer_to_this_is_0_on_buggy_compilers;
<a name="l01618"></a>01618         StaticFunctionPtr m_nonzero;
<a name="l01619"></a>01619     } UselessTypedef;
<a name="l01620"></a>01620     <span class="keyword">typedef</span> StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
<a name="l01621"></a>01621 <span class="keyword">public</span>:
<a name="l01622"></a>01622     operator unspecified_bool_type()<span class="keyword"> const </span>{
<a name="l01623"></a>01623         <span class="keywordflow">return</span> empty()? 0: &amp;SafeBoolStruct::m_nonzero;
<a name="l01624"></a>01624     }
<a name="l01625"></a>01625     <span class="comment">// necessary to allow ==0 to work despite the safe_bool idiom</span>
<a name="l01626"></a>01626     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(StaticFunctionPtr funcptr) {
<a name="l01627"></a>01627         <span class="keywordflow">return</span> m_Closure.IsEqualToStaticFuncPtr(funcptr);   }
<a name="l01628"></a>01628     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator!=(StaticFunctionPtr funcptr) { 
<a name="l01629"></a>01629         <span class="keywordflow">return</span> !m_Closure.IsEqualToStaticFuncPtr(funcptr);    }
<a name="l01630"></a>01630     <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator ! ()<span class="keyword"> const </span>{   <span class="comment">// Is it bound to anything?</span>
<a name="l01631"></a>01631             <span class="keywordflow">return</span> !m_Closure; }
<a name="l01632"></a>01632     <span class="keyword">inline</span> <span class="keywordtype">bool</span> empty()<span class="keyword"> const   </span>{
<a name="l01633"></a>01633             <span class="keywordflow">return</span> !m_Closure; }
<a name="l01634"></a>01634     <span class="keywordtype">void</span> clear() { m_Closure.clear();}
<a name="l01635"></a>01635     <span class="comment">// Conversion to and from the delegate_memento storage class</span>
<a name="l01636"></a>01636     <span class="keyword">const</span> delegate_memento &amp; get_memento()<span class="keyword">const </span>{ <span class="keywordflow">return</span> m_Closure; }
<a name="l01637"></a>01637     <span class="keywordtype">void</span> set_memento(<span class="keyword">const</span> delegate_memento &amp;any) { m_Closure.CopyFrom(<span class="keyword">this</span>, any); }
<a name="l01638"></a>01638 
<a name="l01639"></a>01639 <span class="keyword">private</span>:    <span class="comment">// Invoker for static functions</span>
<a name="l01640"></a>01640     RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8)<span class="keyword"> const </span>{
<a name="l01641"></a>01641     <span class="keywordflow">return</span> (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6, p7, p8); }
<a name="l01642"></a>01642 };
<a name="l01643"></a>01643 
<a name="l01644"></a>01644 <span class="comment"></span>
<a name="l01645"></a>01645 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l01646"></a>01646 <span class="comment"></span><span class="comment">//                      Fast Delegates, part 4:</span>
<a name="l01647"></a>01647 <span class="comment">// </span>
<a name="l01648"></a>01648 <span class="comment">//              fast_delegate&lt;&gt; class (Original author: Jody Hagins)</span>
<a name="l01649"></a>01649 <span class="comment">//  Allows boost::function style syntax like:</span>
<a name="l01650"></a>01650 <span class="comment">//          fast_delegate&lt; double (int, long) &gt;</span>
<a name="l01651"></a>01651 <span class="comment">// instead of:</span>
<a name="l01652"></a>01652 <span class="comment">//          fast_delegate2&lt; int, long, double &gt;</span>
<a name="l01653"></a>01653 <span class="comment">//</span><span class="comment"></span>
<a name="l01654"></a>01654 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l01655"></a>01655 <span class="comment"></span>
<a name="l01656"></a>01656 <span class="preprocessor">#ifdef FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX</span>
<a name="l01657"></a>01657 <span class="preprocessor"></span><span class="comment">/// @endcond FASTDELEGATE</span>
<a name="l01658"></a>01658 <span class="comment"></span>
<a name="l01659"></a>01659 <span class="comment">// Declare fast_delegate as a class template.  It will be specialized</span>
<a name="l01660"></a>01660 <span class="comment">// later for all number of arguments.</span>
<a name="l01661"></a>01661 <span class="comment"></span>
<a name="l01662"></a>01662 <span class="comment">/**</span>
<a name="l01663"></a>01663 <span class="comment">    @class fd::fast_delegate</span>
<a name="l01664"></a>01664 <span class="comment">    @brief Fast, type-safe, member-function callbacks. </span>
<a name="l01665"></a>01665 <span class="comment"></span>
<a name="l01666"></a>01666 <span class="comment">    Allows boost::function style syntax like:</span>
<a name="l01667"></a>01667 <span class="comment">            fast_delegate&lt; double (int, long) &gt;</span>
<a name="l01668"></a>01668 <span class="comment">    instead of: &lt;br/&gt;</span>
<a name="l01669"></a>01669 <span class="comment">            fast_delegate2&lt; int, long, double &gt;</span>
<a name="l01670"></a>01670 <span class="comment"></span>
<a name="l01671"></a>01671 <span class="comment">    fast_delegate provides efficient delegates in C++ that generate only two lines of asm code!</span>
<a name="l01672"></a>01672 <span class="comment">    Documentation is found at http://www.codeproject.com/cpp/fast_delegate.asp</span>
<a name="l01673"></a>01673 <span class="comment"></span>
<a name="l01674"></a>01674 <span class="comment">    @section why_not_boost_function Why not use Boost.Function?</span>
<a name="l01675"></a>01675 <span class="comment">    </span>
<a name="l01676"></a>01676 <span class="comment">    The fast_delegate implementation was chosen over boost::function&lt;&gt; because boost::function&lt;&gt; depended upon RTTI and</span>
<a name="l01677"></a>01677 <span class="comment">    heap allocations.  RTTI was unacceptable for embedded applications and heap allocations were</span>
<a name="l01678"></a>01678 <span class="comment">    unacceptable for both embedded and high-performance active object implementations that are</span>
<a name="l01679"></a>01679 <span class="comment">    creating and destroying function pointers on a regular basis.</span>
<a name="l01680"></a>01680 <span class="comment"></span>
<a name="l01681"></a>01681 <span class="comment"> </span>
<a name="l01682"></a>01682 <span class="comment">    @section fast_delegate_licences Fast Delegate License</span>
<a name="l01683"></a>01683 <span class="comment"></span>
<a name="l01684"></a>01684 <span class="comment">    fast_delegate is licensed under &lt;a href=&quot;http://www.codeproject.com/info/cpol10.aspx&quot;&gt;The Code Project Open License&lt;/a&gt;:</span>
<a name="l01685"></a>01685 <span class="comment">    &lt;hr/&gt;</span>
<a name="l01686"></a>01686 <span class="comment">    This License governs Your use of the Work. This License is intended to allow developers to use the Source Code and Executable Files provided as part of the Work in any application in any form.</span>
<a name="l01687"></a>01687 <span class="comment"></span>
<a name="l01688"></a>01688 <span class="comment">    The main points subject to the terms of the License are:</span>
<a name="l01689"></a>01689 <span class="comment"></span>
<a name="l01690"></a>01690 <span class="comment">        - Source Code and Executable Files can be used in commercial applications;</span>
<a name="l01691"></a>01691 <span class="comment">        - Source Code and Executable Files can be redistributed; and</span>
<a name="l01692"></a>01692 <span class="comment">        - Source Code can be modified to create derivative works.</span>
<a name="l01693"></a>01693 <span class="comment">        - No claim of suitability, guarantee, or any warranty whatsoever is provided. The software is provided &quot;as-is&quot;.</span>
<a name="l01694"></a>01694 <span class="comment">        - The Article(s) accompanying the Work may not be distributed or republished without the Author&#39;s consent</span>
<a name="l01695"></a>01695 <span class="comment"></span>
<a name="l01696"></a>01696 <span class="comment">    This License is entered between You, the individual or other entity reading or otherwise making use of the Work licensed pursuant to this License and the individual or other entity which offers the Work under the terms of this License (&quot;Author&quot;).</span>
<a name="l01697"></a>01697 <span class="comment">    &lt;hr/&gt;</span>
<a name="l01698"></a>01698 <span class="comment"></span>
<a name="l01699"></a>01699 <span class="comment">    @author (Original author: Jody Hagins)</span>
<a name="l01700"></a>01700 <span class="comment">*/</span>
<a name="l01701"></a>01701 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Signature&gt;
<a name="l01702"></a>01702 <span class="keyword">class </span>fast_delegate;
<a name="l01703"></a>01703 <span class="comment"></span>
<a name="l01704"></a>01704 <span class="comment">/// @cond FASTDELEGATE</span>
<a name="l01705"></a>01705 <span class="comment"></span>
<a name="l01706"></a>01706 <span class="comment">//N=0</span>
<a name="l01707"></a>01707 <span class="comment">// Specialization to allow use of</span>
<a name="l01708"></a>01708 <span class="comment">// fast_delegate&lt; R (  ) &gt;</span>
<a name="l01709"></a>01709 <span class="comment">// instead of </span>
<a name="l01710"></a>01710 <span class="comment">// fast_delegate0 &lt; R &gt;</span>
<a name="l01711"></a>01711 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;
<a name="l01712"></a>01712 <span class="keyword">class </span>fast_delegate&lt; R (  ) &gt;
<a name="l01713"></a>01713   <span class="comment">// Inherit from fast_delegate0 so that it can be treated just like a fast_delegate0</span>
<a name="l01714"></a>01714   : <span class="keyword">public</span> fast_delegate0 &lt; R &gt;
<a name="l01715"></a>01715 {
<a name="l01716"></a>01716 <span class="keyword">public</span>:
<a name="l01717"></a>01717   <span class="comment">// Make using the base type a bit easier via typedef.</span>
<a name="l01718"></a>01718   <span class="keyword">typedef</span> fast_delegate0 &lt; R &gt; BaseType;
<a name="l01719"></a>01719 
<a name="l01720"></a>01720   <span class="comment">// Allow users access to the specific type of this delegate.</span>
<a name="l01721"></a>01721   <span class="keyword">typedef</span> fast_delegate SelfType;
<a name="l01722"></a>01722 
<a name="l01723"></a>01723   <span class="comment">// Mimic the base class constructors.</span>
<a name="l01724"></a>01724   fast_delegate() : BaseType() { }
<a name="l01725"></a>01725 
<a name="l01726"></a>01726   <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01727"></a>01727   fast_delegate(Y * pthis, 
<a name="l01728"></a>01728     R (X::* function_to_bind)(  ))
<a name="l01729"></a>01729     : BaseType(pthis, function_to_bind)  { }
<a name="l01730"></a>01730 
<a name="l01731"></a>01731   <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01732"></a>01732   fast_delegate(<span class="keyword">const</span> Y *pthis,
<a name="l01733"></a>01733       R (X::* function_to_bind)(  ) <span class="keyword">const</span>)
<a name="l01734"></a>01734     : BaseType(pthis, function_to_bind)
<a name="l01735"></a>01735   {  }
<a name="l01736"></a>01736 
<a name="l01737"></a>01737   fast_delegate(R (*function_to_bind)(  ))
<a name="l01738"></a>01738     : BaseType(function_to_bind)  { }
<a name="l01739"></a>01739   <span class="keywordtype">void</span> operator = (<span class="keyword">const</span> BaseType &amp;x)  {      
<a name="l01740"></a>01740         *<span class="keyword">static_cast&lt;</span>BaseType*<span class="keyword">&gt;</span>(<span class="keyword">this</span>) = x; }
<a name="l01741"></a>01741 };
<a name="l01742"></a>01742 
<a name="l01743"></a>01743 <span class="comment">//N=1</span>
<a name="l01744"></a>01744 <span class="comment">// Specialization to allow use of</span>
<a name="l01745"></a>01745 <span class="comment">// fast_delegate&lt; R ( Param1 ) &gt;</span>
<a name="l01746"></a>01746 <span class="comment">// instead of </span>
<a name="l01747"></a>01747 <span class="comment">// fast_delegate1 &lt; Param1, R &gt;</span>
<a name="l01748"></a>01748 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">class</span> Param1&gt;
<a name="l01749"></a>01749 <span class="keyword">class </span>fast_delegate&lt; R ( Param1 ) &gt;
<a name="l01750"></a>01750   <span class="comment">// Inherit from fast_delegate1 so that it can be treated just like a fast_delegate1</span>
<a name="l01751"></a>01751   : <span class="keyword">public</span> fast_delegate1 &lt; Param1, R &gt;
<a name="l01752"></a>01752 {
<a name="l01753"></a>01753 <span class="keyword">public</span>:
<a name="l01754"></a>01754   <span class="comment">// Make using the base type a bit easier via typedef.</span>
<a name="l01755"></a>01755   <span class="keyword">typedef</span> fast_delegate1 &lt; Param1, R &gt; BaseType;
<a name="l01756"></a>01756 
<a name="l01757"></a>01757   <span class="comment">// Allow users access to the specific type of this delegate.</span>
<a name="l01758"></a>01758   <span class="keyword">typedef</span> fast_delegate SelfType;
<a name="l01759"></a>01759 
<a name="l01760"></a>01760   <span class="comment">// Mimic the base class constructors.</span>
<a name="l01761"></a>01761   fast_delegate() : BaseType() { }
<a name="l01762"></a>01762 
<a name="l01763"></a>01763   <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01764"></a>01764   fast_delegate(Y * pthis, 
<a name="l01765"></a>01765     R (X::* function_to_bind)( Param1 p1 ))
<a name="l01766"></a>01766     : BaseType(pthis, function_to_bind)  { }
<a name="l01767"></a>01767 
<a name="l01768"></a>01768   <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01769"></a>01769   fast_delegate(<span class="keyword">const</span> Y *pthis,
<a name="l01770"></a>01770       R (X::* function_to_bind)( Param1 p1 ) <span class="keyword">const</span>)
<a name="l01771"></a>01771     : BaseType(pthis, function_to_bind)
<a name="l01772"></a>01772   {  }
<a name="l01773"></a>01773 
<a name="l01774"></a>01774   fast_delegate(R (*function_to_bind)( Param1 p1 ))
<a name="l01775"></a>01775     : BaseType(function_to_bind)  { }
<a name="l01776"></a>01776   <span class="keywordtype">void</span> operator = (<span class="keyword">const</span> BaseType &amp;x)  {      
<a name="l01777"></a>01777         *<span class="keyword">static_cast&lt;</span>BaseType*<span class="keyword">&gt;</span>(<span class="keyword">this</span>) = x; }
<a name="l01778"></a>01778 };
<a name="l01779"></a>01779 
<a name="l01780"></a>01780 <span class="comment">//N=2</span>
<a name="l01781"></a>01781 <span class="comment">// Specialization to allow use of</span>
<a name="l01782"></a>01782 <span class="comment">// fast_delegate&lt; R ( Param1, Param2 ) &gt;</span>
<a name="l01783"></a>01783 <span class="comment">// instead of </span>
<a name="l01784"></a>01784 <span class="comment">// fast_delegate2 &lt; Param1, Param2, R &gt;</span>
<a name="l01785"></a>01785 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">class</span> Param1, <span class="keyword">class</span> Param2&gt;
<a name="l01786"></a>01786 <span class="keyword">class </span>fast_delegate&lt; R ( Param1, Param2 ) &gt;
<a name="l01787"></a>01787   <span class="comment">// Inherit from fast_delegate2 so that it can be treated just like a fast_delegate2</span>
<a name="l01788"></a>01788   : <span class="keyword">public</span> fast_delegate2 &lt; Param1, Param2, R &gt;
<a name="l01789"></a>01789 {
<a name="l01790"></a>01790 <span class="keyword">public</span>:
<a name="l01791"></a>01791   <span class="comment">// Make using the base type a bit easier via typedef.</span>
<a name="l01792"></a>01792   <span class="keyword">typedef</span> fast_delegate2 &lt; Param1, Param2, R &gt; BaseType;
<a name="l01793"></a>01793 
<a name="l01794"></a>01794   <span class="comment">// Allow users access to the specific type of this delegate.</span>
<a name="l01795"></a>01795   <span class="keyword">typedef</span> fast_delegate SelfType;
<a name="l01796"></a>01796 
<a name="l01797"></a>01797   <span class="comment">// Mimic the base class constructors.</span>
<a name="l01798"></a>01798   fast_delegate() : BaseType() { }
<a name="l01799"></a>01799 
<a name="l01800"></a>01800   <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01801"></a>01801   fast_delegate(Y * pthis, 
<a name="l01802"></a>01802     R (X::* function_to_bind)( Param1 p1, Param2 p2 ))
<a name="l01803"></a>01803     : BaseType(pthis, function_to_bind)  { }
<a name="l01804"></a>01804 
<a name="l01805"></a>01805   <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01806"></a>01806   fast_delegate(<span class="keyword">const</span> Y *pthis,
<a name="l01807"></a>01807       R (X::* function_to_bind)( Param1 p1, Param2 p2 ) <span class="keyword">const</span>)
<a name="l01808"></a>01808     : BaseType(pthis, function_to_bind)
<a name="l01809"></a>01809   {  }
<a name="l01810"></a>01810 
<a name="l01811"></a>01811   fast_delegate(R (*function_to_bind)( Param1 p1, Param2 p2 ))
<a name="l01812"></a>01812     : BaseType(function_to_bind)  { }
<a name="l01813"></a>01813   <span class="keywordtype">void</span> operator = (<span class="keyword">const</span> BaseType &amp;x)  {      
<a name="l01814"></a>01814         *<span class="keyword">static_cast&lt;</span>BaseType*<span class="keyword">&gt;</span>(<span class="keyword">this</span>) = x; }
<a name="l01815"></a>01815 };
<a name="l01816"></a>01816 
<a name="l01817"></a>01817 <span class="comment">//N=3</span>
<a name="l01818"></a>01818 <span class="comment">// Specialization to allow use of</span>
<a name="l01819"></a>01819 <span class="comment">// fast_delegate&lt; R ( Param1, Param2, Param3 ) &gt;</span>
<a name="l01820"></a>01820 <span class="comment">// instead of </span>
<a name="l01821"></a>01821 <span class="comment">// fast_delegate3 &lt; Param1, Param2, Param3, R &gt;</span>
<a name="l01822"></a>01822 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">class</span> Param1, <span class="keyword">class</span> Param2, <span class="keyword">class</span> Param3&gt;
<a name="l01823"></a>01823 <span class="keyword">class </span>fast_delegate&lt; R ( Param1, Param2, Param3 ) &gt;
<a name="l01824"></a>01824   <span class="comment">// Inherit from fast_delegate3 so that it can be treated just like a fast_delegate3</span>
<a name="l01825"></a>01825   : <span class="keyword">public</span> fast_delegate3 &lt; Param1, Param2, Param3, R &gt;
<a name="l01826"></a>01826 {
<a name="l01827"></a>01827 <span class="keyword">public</span>:
<a name="l01828"></a>01828   <span class="comment">// Make using the base type a bit easier via typedef.</span>
<a name="l01829"></a>01829   <span class="keyword">typedef</span> fast_delegate3 &lt; Param1, Param2, Param3, R &gt; BaseType;
<a name="l01830"></a>01830 
<a name="l01831"></a>01831   <span class="comment">// Allow users access to the specific type of this delegate.</span>
<a name="l01832"></a>01832   <span class="keyword">typedef</span> fast_delegate SelfType;
<a name="l01833"></a>01833 
<a name="l01834"></a>01834   <span class="comment">// Mimic the base class constructors.</span>
<a name="l01835"></a>01835   fast_delegate() : BaseType() { }
<a name="l01836"></a>01836 
<a name="l01837"></a>01837   <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01838"></a>01838   fast_delegate(Y * pthis, 
<a name="l01839"></a>01839     R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3 ))
<a name="l01840"></a>01840     : BaseType(pthis, function_to_bind)  { }
<a name="l01841"></a>01841 
<a name="l01842"></a>01842   <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01843"></a>01843   fast_delegate(<span class="keyword">const</span> Y *pthis,
<a name="l01844"></a>01844       R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3 ) <span class="keyword">const</span>)
<a name="l01845"></a>01845     : BaseType(pthis, function_to_bind)
<a name="l01846"></a>01846   {  }
<a name="l01847"></a>01847 
<a name="l01848"></a>01848   fast_delegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3 ))
<a name="l01849"></a>01849     : BaseType(function_to_bind)  { }
<a name="l01850"></a>01850   <span class="keywordtype">void</span> operator = (<span class="keyword">const</span> BaseType &amp;x)  {      
<a name="l01851"></a>01851         *<span class="keyword">static_cast&lt;</span>BaseType*<span class="keyword">&gt;</span>(<span class="keyword">this</span>) = x; }
<a name="l01852"></a>01852 };
<a name="l01853"></a>01853 
<a name="l01854"></a>01854 <span class="comment">//N=4</span>
<a name="l01855"></a>01855 <span class="comment">// Specialization to allow use of</span>
<a name="l01856"></a>01856 <span class="comment">// fast_delegate&lt; R ( Param1, Param2, Param3, Param4 ) &gt;</span>
<a name="l01857"></a>01857 <span class="comment">// instead of </span>
<a name="l01858"></a>01858 <span class="comment">// fast_delegate4 &lt; Param1, Param2, Param3, Param4, R &gt;</span>
<a name="l01859"></a>01859 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">class</span> Param1, <span class="keyword">class</span> Param2, <span class="keyword">class</span> Param3, <span class="keyword">class</span> Param4&gt;
<a name="l01860"></a>01860 <span class="keyword">class </span>fast_delegate&lt; R ( Param1, Param2, Param3, Param4 ) &gt;
<a name="l01861"></a>01861   <span class="comment">// Inherit from fast_delegate4 so that it can be treated just like a fast_delegate4</span>
<a name="l01862"></a>01862   : <span class="keyword">public</span> fast_delegate4 &lt; Param1, Param2, Param3, Param4, R &gt;
<a name="l01863"></a>01863 {
<a name="l01864"></a>01864 <span class="keyword">public</span>:
<a name="l01865"></a>01865   <span class="comment">// Make using the base type a bit easier via typedef.</span>
<a name="l01866"></a>01866   <span class="keyword">typedef</span> fast_delegate4 &lt; Param1, Param2, Param3, Param4, R &gt; BaseType;
<a name="l01867"></a>01867 
<a name="l01868"></a>01868   <span class="comment">// Allow users access to the specific type of this delegate.</span>
<a name="l01869"></a>01869   <span class="keyword">typedef</span> fast_delegate SelfType;
<a name="l01870"></a>01870 
<a name="l01871"></a>01871   <span class="comment">// Mimic the base class constructors.</span>
<a name="l01872"></a>01872   fast_delegate() : BaseType() { }
<a name="l01873"></a>01873 
<a name="l01874"></a>01874   <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01875"></a>01875   fast_delegate(Y * pthis, 
<a name="l01876"></a>01876     R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ))
<a name="l01877"></a>01877     : BaseType(pthis, function_to_bind)  { }
<a name="l01878"></a>01878 
<a name="l01879"></a>01879   <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01880"></a>01880   fast_delegate(<span class="keyword">const</span> Y *pthis,
<a name="l01881"></a>01881       R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ) <span class="keyword">const</span>)
<a name="l01882"></a>01882     : BaseType(pthis, function_to_bind)
<a name="l01883"></a>01883   {  }
<a name="l01884"></a>01884 
<a name="l01885"></a>01885   fast_delegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ))
<a name="l01886"></a>01886     : BaseType(function_to_bind)  { }
<a name="l01887"></a>01887   <span class="keywordtype">void</span> operator = (<span class="keyword">const</span> BaseType &amp;x)  {      
<a name="l01888"></a>01888         *<span class="keyword">static_cast&lt;</span>BaseType*<span class="keyword">&gt;</span>(<span class="keyword">this</span>) = x; }
<a name="l01889"></a>01889 };
<a name="l01890"></a>01890 
<a name="l01891"></a>01891 <span class="comment">//N=5</span>
<a name="l01892"></a>01892 <span class="comment">// Specialization to allow use of</span>
<a name="l01893"></a>01893 <span class="comment">// fast_delegate&lt; R ( Param1, Param2, Param3, Param4, Param5 ) &gt;</span>
<a name="l01894"></a>01894 <span class="comment">// instead of </span>
<a name="l01895"></a>01895 <span class="comment">// fast_delegate5 &lt; Param1, Param2, Param3, Param4, Param5, R &gt;</span>
<a name="l01896"></a>01896 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">class</span> Param1, <span class="keyword">class</span> Param2, <span class="keyword">class</span> Param3, <span class="keyword">class</span> Param4, <span class="keyword">class</span> Param5&gt;
<a name="l01897"></a>01897 <span class="keyword">class </span>fast_delegate&lt; R ( Param1, Param2, Param3, Param4, Param5 ) &gt;
<a name="l01898"></a>01898   <span class="comment">// Inherit from fast_delegate5 so that it can be treated just like a fast_delegate5</span>
<a name="l01899"></a>01899   : <span class="keyword">public</span> fast_delegate5 &lt; Param1, Param2, Param3, Param4, Param5, R &gt;
<a name="l01900"></a>01900 {
<a name="l01901"></a>01901 <span class="keyword">public</span>:
<a name="l01902"></a>01902   <span class="comment">// Make using the base type a bit easier via typedef.</span>
<a name="l01903"></a>01903   <span class="keyword">typedef</span> fast_delegate5 &lt; Param1, Param2, Param3, Param4, Param5, R &gt; BaseType;
<a name="l01904"></a>01904 
<a name="l01905"></a>01905   <span class="comment">// Allow users access to the specific type of this delegate.</span>
<a name="l01906"></a>01906   <span class="keyword">typedef</span> fast_delegate SelfType;
<a name="l01907"></a>01907 
<a name="l01908"></a>01908   <span class="comment">// Mimic the base class constructors.</span>
<a name="l01909"></a>01909   fast_delegate() : BaseType() { }
<a name="l01910"></a>01910 
<a name="l01911"></a>01911   <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01912"></a>01912   fast_delegate(Y * pthis, 
<a name="l01913"></a>01913     R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ))
<a name="l01914"></a>01914     : BaseType(pthis, function_to_bind)  { }
<a name="l01915"></a>01915 
<a name="l01916"></a>01916   <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01917"></a>01917   fast_delegate(<span class="keyword">const</span> Y *pthis,
<a name="l01918"></a>01918       R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ) <span class="keyword">const</span>)
<a name="l01919"></a>01919     : BaseType(pthis, function_to_bind)
<a name="l01920"></a>01920   {  }
<a name="l01921"></a>01921 
<a name="l01922"></a>01922   fast_delegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ))
<a name="l01923"></a>01923     : BaseType(function_to_bind)  { }
<a name="l01924"></a>01924   <span class="keywordtype">void</span> operator = (<span class="keyword">const</span> BaseType &amp;x)  {      
<a name="l01925"></a>01925         *<span class="keyword">static_cast&lt;</span>BaseType*<span class="keyword">&gt;</span>(<span class="keyword">this</span>) = x; }
<a name="l01926"></a>01926 };
<a name="l01927"></a>01927 
<a name="l01928"></a>01928 <span class="comment">//N=6</span>
<a name="l01929"></a>01929 <span class="comment">// Specialization to allow use of</span>
<a name="l01930"></a>01930 <span class="comment">// fast_delegate&lt; R ( Param1, Param2, Param3, Param4, Param5, Param6 ) &gt;</span>
<a name="l01931"></a>01931 <span class="comment">// instead of </span>
<a name="l01932"></a>01932 <span class="comment">// fast_delegate6 &lt; Param1, Param2, Param3, Param4, Param5, Param6, R &gt;</span>
<a name="l01933"></a>01933 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">class</span> Param1, <span class="keyword">class</span> Param2, <span class="keyword">class</span> Param3, <span class="keyword">class</span> Param4, <span class="keyword">class</span> Param5, <span class="keyword">class</span> Param6&gt;
<a name="l01934"></a>01934 <span class="keyword">class </span>fast_delegate&lt; R ( Param1, Param2, Param3, Param4, Param5, Param6 ) &gt;
<a name="l01935"></a>01935   <span class="comment">// Inherit from fast_delegate6 so that it can be treated just like a fast_delegate6</span>
<a name="l01936"></a>01936   : <span class="keyword">public</span> fast_delegate6 &lt; Param1, Param2, Param3, Param4, Param5, Param6, R &gt;
<a name="l01937"></a>01937 {
<a name="l01938"></a>01938 <span class="keyword">public</span>:
<a name="l01939"></a>01939   <span class="comment">// Make using the base type a bit easier via typedef.</span>
<a name="l01940"></a>01940   <span class="keyword">typedef</span> fast_delegate6 &lt; Param1, Param2, Param3, Param4, Param5, Param6, R &gt; BaseType;
<a name="l01941"></a>01941 
<a name="l01942"></a>01942   <span class="comment">// Allow users access to the specific type of this delegate.</span>
<a name="l01943"></a>01943   <span class="keyword">typedef</span> fast_delegate SelfType;
<a name="l01944"></a>01944 
<a name="l01945"></a>01945   <span class="comment">// Mimic the base class constructors.</span>
<a name="l01946"></a>01946   fast_delegate() : BaseType() { }
<a name="l01947"></a>01947 
<a name="l01948"></a>01948   <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01949"></a>01949   fast_delegate(Y * pthis, 
<a name="l01950"></a>01950     R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ))
<a name="l01951"></a>01951     : BaseType(pthis, function_to_bind)  { }
<a name="l01952"></a>01952 
<a name="l01953"></a>01953   <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01954"></a>01954   fast_delegate(<span class="keyword">const</span> Y *pthis,
<a name="l01955"></a>01955       R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ) <span class="keyword">const</span>)
<a name="l01956"></a>01956     : BaseType(pthis, function_to_bind)
<a name="l01957"></a>01957   {  }
<a name="l01958"></a>01958 
<a name="l01959"></a>01959   fast_delegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ))
<a name="l01960"></a>01960     : BaseType(function_to_bind)  { }
<a name="l01961"></a>01961   <span class="keywordtype">void</span> operator = (<span class="keyword">const</span> BaseType &amp;x)  {      
<a name="l01962"></a>01962         *<span class="keyword">static_cast&lt;</span>BaseType*<span class="keyword">&gt;</span>(<span class="keyword">this</span>) = x; }
<a name="l01963"></a>01963 };
<a name="l01964"></a>01964 
<a name="l01965"></a>01965 <span class="comment">//N=7</span>
<a name="l01966"></a>01966 <span class="comment">// Specialization to allow use of</span>
<a name="l01967"></a>01967 <span class="comment">// fast_delegate&lt; R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7 ) &gt;</span>
<a name="l01968"></a>01968 <span class="comment">// instead of </span>
<a name="l01969"></a>01969 <span class="comment">// fast_delegate7 &lt; Param1, Param2, Param3, Param4, Param5, Param6, Param7, R &gt;</span>
<a name="l01970"></a>01970 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">class</span> Param1, <span class="keyword">class</span> Param2, <span class="keyword">class</span> Param3, <span class="keyword">class</span> Param4, <span class="keyword">class</span> Param5, <span class="keyword">class</span> Param6, <span class="keyword">class</span> Param7&gt;
<a name="l01971"></a>01971 <span class="keyword">class </span>fast_delegate&lt; R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7 ) &gt;
<a name="l01972"></a>01972   <span class="comment">// Inherit from fast_delegate7 so that it can be treated just like a fast_delegate7</span>
<a name="l01973"></a>01973   : <span class="keyword">public</span> fast_delegate7 &lt; Param1, Param2, Param3, Param4, Param5, Param6, Param7, R &gt;
<a name="l01974"></a>01974 {
<a name="l01975"></a>01975 <span class="keyword">public</span>:
<a name="l01976"></a>01976   <span class="comment">// Make using the base type a bit easier via typedef.</span>
<a name="l01977"></a>01977   <span class="keyword">typedef</span> fast_delegate7 &lt; Param1, Param2, Param3, Param4, Param5, Param6, Param7, R &gt; BaseType;
<a name="l01978"></a>01978 
<a name="l01979"></a>01979   <span class="comment">// Allow users access to the specific type of this delegate.</span>
<a name="l01980"></a>01980   <span class="keyword">typedef</span> fast_delegate SelfType;
<a name="l01981"></a>01981 
<a name="l01982"></a>01982   <span class="comment">// Mimic the base class constructors.</span>
<a name="l01983"></a>01983   fast_delegate() : BaseType() { }
<a name="l01984"></a>01984 
<a name="l01985"></a>01985   <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01986"></a>01986   fast_delegate(Y * pthis, 
<a name="l01987"></a>01987     R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ))
<a name="l01988"></a>01988     : BaseType(pthis, function_to_bind)  { }
<a name="l01989"></a>01989 
<a name="l01990"></a>01990   <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l01991"></a>01991   fast_delegate(<span class="keyword">const</span> Y *pthis,
<a name="l01992"></a>01992       R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ) <span class="keyword">const</span>)
<a name="l01993"></a>01993     : BaseType(pthis, function_to_bind)
<a name="l01994"></a>01994   {  }
<a name="l01995"></a>01995 
<a name="l01996"></a>01996   fast_delegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ))
<a name="l01997"></a>01997     : BaseType(function_to_bind)  { }
<a name="l01998"></a>01998   <span class="keywordtype">void</span> operator = (<span class="keyword">const</span> BaseType &amp;x)  {      
<a name="l01999"></a>01999         *<span class="keyword">static_cast&lt;</span>BaseType*<span class="keyword">&gt;</span>(<span class="keyword">this</span>) = x; }
<a name="l02000"></a>02000 };
<a name="l02001"></a>02001 
<a name="l02002"></a>02002 <span class="comment">//N=8</span>
<a name="l02003"></a>02003 <span class="comment">// Specialization to allow use of</span>
<a name="l02004"></a>02004 <span class="comment">// fast_delegate&lt; R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8 ) &gt;</span>
<a name="l02005"></a>02005 <span class="comment">// instead of </span>
<a name="l02006"></a>02006 <span class="comment">// fast_delegate8 &lt; Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, R &gt;</span>
<a name="l02007"></a>02007 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">class</span> Param1, <span class="keyword">class</span> Param2, <span class="keyword">class</span> Param3, <span class="keyword">class</span> Param4, <span class="keyword">class</span> Param5, <span class="keyword">class</span> Param6, <span class="keyword">class</span> Param7, <span class="keyword">class</span> Param8&gt;
<a name="l02008"></a>02008 <span class="keyword">class </span>fast_delegate&lt; R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8 ) &gt;
<a name="l02009"></a>02009   <span class="comment">// Inherit from fast_delegate8 so that it can be treated just like a fast_delegate8</span>
<a name="l02010"></a>02010   : <span class="keyword">public</span> fast_delegate8 &lt; Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, R &gt;
<a name="l02011"></a>02011 {
<a name="l02012"></a>02012 <span class="keyword">public</span>:
<a name="l02013"></a>02013   <span class="comment">// Make using the base type a bit easier via typedef.</span>
<a name="l02014"></a>02014   <span class="keyword">typedef</span> fast_delegate8 &lt; Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, R &gt; BaseType;
<a name="l02015"></a>02015 
<a name="l02016"></a>02016   <span class="comment">// Allow users access to the specific type of this delegate.</span>
<a name="l02017"></a>02017   <span class="keyword">typedef</span> fast_delegate SelfType;
<a name="l02018"></a>02018 
<a name="l02019"></a>02019   <span class="comment">// Mimic the base class constructors.</span>
<a name="l02020"></a>02020   fast_delegate() : BaseType() { }
<a name="l02021"></a>02021 
<a name="l02022"></a>02022   <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l02023"></a>02023   fast_delegate(Y * pthis, 
<a name="l02024"></a>02024     R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ))
<a name="l02025"></a>02025     : BaseType(pthis, function_to_bind)  { }
<a name="l02026"></a>02026 
<a name="l02027"></a>02027   <span class="keyword">template</span> &lt; <span class="keyword">class</span> X, <span class="keyword">class</span> Y &gt;
<a name="l02028"></a>02028   fast_delegate(<span class="keyword">const</span> Y *pthis,
<a name="l02029"></a>02029       R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ) <span class="keyword">const</span>)
<a name="l02030"></a>02030     : BaseType(pthis, function_to_bind)
<a name="l02031"></a>02031   {  }
<a name="l02032"></a>02032 
<a name="l02033"></a>02033   fast_delegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ))
<a name="l02034"></a>02034     : BaseType(function_to_bind)  { }
<a name="l02035"></a>02035   <span class="keywordtype">void</span> operator = (<span class="keyword">const</span> BaseType &amp;x)  {      
<a name="l02036"></a>02036         *<span class="keyword">static_cast&lt;</span>BaseType*<span class="keyword">&gt;</span>(<span class="keyword">this</span>) = x; }
<a name="l02037"></a>02037 };
<a name="l02038"></a>02038 
<a name="l02039"></a>02039 
<a name="l02040"></a>02040 <span class="preprocessor">#endif //FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX</span>
<a name="l02041"></a>02041 <span class="preprocessor"></span><span class="comment"></span>
<a name="l02042"></a>02042 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l02043"></a>02043 <span class="comment"></span><span class="comment">//                      Fast Delegates, part 5:</span>
<a name="l02044"></a>02044 <span class="comment">//</span>
<a name="l02045"></a>02045 <span class="comment">//              make_fast_delegate() helper function</span>
<a name="l02046"></a>02046 <span class="comment">//</span>
<a name="l02047"></a>02047 <span class="comment">//          make_fast_delegate(&amp;x, &amp;X::func) returns a fastdelegate of the type</span>
<a name="l02048"></a>02048 <span class="comment">//          necessary for calling x.func() with the correct number of arguments.</span>
<a name="l02049"></a>02049 <span class="comment">//          This makes it possible to eliminate many typedefs from user code.</span>
<a name="l02050"></a>02050 <span class="comment">//</span><span class="comment"></span>
<a name="l02051"></a>02051 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l02052"></a>02052 <span class="comment"></span>
<a name="l02053"></a>02053 <span class="comment">// Also declare overloads of a make_fast_delegate() global function to </span>
<a name="l02054"></a>02054 <span class="comment">// reduce the need for typedefs.</span>
<a name="l02055"></a>02055 <span class="comment">// We need seperate overloads for const and non-const member functions.</span>
<a name="l02056"></a>02056 <span class="comment">// Also, because of the weird rule about the class of derived member function pointers,</span>
<a name="l02057"></a>02057 <span class="comment">// implicit downcasts may need to be applied later to the &#39;this&#39; pointer.</span>
<a name="l02058"></a>02058 <span class="comment">// That&#39;s why two classes (X and Y) appear in the definitions. Y must be implicitly</span>
<a name="l02059"></a>02059 <span class="comment">// castable to X.</span>
<a name="l02060"></a>02060 
<a name="l02061"></a>02061 <span class="comment">// Workaround for VC6. VC6 needs void return types converted into DefaultVoid.</span>
<a name="l02062"></a>02062 <span class="comment">// GCC 3.2 and later won&#39;t compile this unless it&#39;s preceded by &#39;typename&#39;,</span>
<a name="l02063"></a>02063 <span class="comment">// but VC6 doesn&#39;t allow &#39;typename&#39; in this context.</span>
<a name="l02064"></a>02064 <span class="comment">// So, I have to use a macro.</span>
<a name="l02065"></a>02065 
<a name="l02066"></a>02066 <span class="preprocessor">#ifdef FASTDLGT_VC6</span>
<a name="l02067"></a>02067 <span class="preprocessor"></span><span class="preprocessor">#define FASTDLGT_RETTYPE detail::void_to_default_void&lt;RetType&gt;::type</span>
<a name="l02068"></a>02068 <span class="preprocessor"></span><span class="preprocessor">#else </span>
<a name="l02069"></a>02069 <span class="preprocessor"></span><span class="preprocessor">#define FASTDLGT_RETTYPE RetType</span>
<a name="l02070"></a>02070 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l02071"></a>02071 <span class="preprocessor"></span>
<a name="l02072"></a>02072 <span class="comment">//N=0</span>
<a name="l02073"></a>02073 <span class="keyword">template</span> &lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y, <span class="keyword">class</span> RetType&gt;
<a name="l02074"></a>02074 fast_delegate&lt;FASTDLGT_RETTYPE()&gt; make_fast_delegate(Y* x, RetType (X::*func)()) { 
<a name="l02075"></a>02075     <span class="keywordflow">return</span> fast_delegate&lt;FASTDLGT_RETTYPE()&gt;(x, func);
<a name="l02076"></a>02076 }
<a name="l02077"></a>02077 
<a name="l02078"></a>02078 <span class="keyword">template</span> &lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y, <span class="keyword">class</span> RetType&gt;
<a name="l02079"></a>02079 fast_delegate&lt;FASTDLGT_RETTYPE()&gt; make_fast_delegate(Y* x, RetType (X::*func)() <span class="keyword">const</span>) { 
<a name="l02080"></a>02080     <span class="keywordflow">return</span> fast_delegate&lt;FASTDLGT_RETTYPE()&gt;(x, func);
<a name="l02081"></a>02081 }
<a name="l02082"></a>02082 
<a name="l02083"></a>02083 <span class="comment">//N=1</span>
<a name="l02084"></a>02084 <span class="keyword">template</span> &lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y, <span class="keyword">class</span> Param1, <span class="keyword">class</span> RetType&gt;
<a name="l02085"></a>02085 fast_delegate&lt;FASTDLGT_RETTYPE(Param1)&gt; make_fast_delegate(Y* x, RetType (X::*func)(Param1 p1)) { 
<a name="l02086"></a>02086     <span class="keywordflow">return</span> fast_delegate&lt;FASTDLGT_RETTYPE(Param1)&gt;(x, func);
<a name="l02087"></a>02087 }
<a name="l02088"></a>02088 
<a name="l02089"></a>02089 <span class="keyword">template</span> &lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y, <span class="keyword">class</span> Param1, <span class="keyword">class</span> RetType&gt;
<a name="l02090"></a>02090 fast_delegate1&lt;FASTDLGT_RETTYPE(Param1)&gt; make_fast_delegate(Y* x, RetType (X::*func)(Param1 p1) <span class="keyword">const</span>) { 
<a name="l02091"></a>02091     <span class="keywordflow">return</span> fast_delegate&lt;FASTDLGT_RETTYPE(Param1)&gt;(x, func);
<a name="l02092"></a>02092 }
<a name="l02093"></a>02093 
<a name="l02094"></a>02094 <span class="comment">//N=2</span>
<a name="l02095"></a>02095 <span class="keyword">template</span> &lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y, <span class="keyword">class</span> Param1, <span class="keyword">class</span> Param2, <span class="keyword">class</span> RetType&gt;
<a name="l02096"></a>02096 fast_delegate&lt;FASTDLGT_RETTYPE(Param1, Param2)&gt; make_fast_delegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2)) { 
<a name="l02097"></a>02097     <span class="keywordflow">return</span> fast_delegate&lt;FASTDLGT_RETTYPE(Param1, Param2)&gt;(x, func);
<a name="l02098"></a>02098 }
<a name="l02099"></a>02099 
<a name="l02100"></a>02100 <span class="keyword">template</span> &lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y, <span class="keyword">class</span> Param1, <span class="keyword">class</span> Param2, <span class="keyword">class</span> RetType&gt;
<a name="l02101"></a>02101 fast_delegate&lt;FASTDLGT_RETTYPE(Param1, Param2)&gt; make_fast_delegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2) <span class="keyword">const</span>) { 
<a name="l02102"></a>02102     <span class="keywordflow">return</span> fast_delegate&lt;FASTDLGT_RETTYPE(Param1, Param2)&gt;(x, func);
<a name="l02103"></a>02103 }
<a name="l02104"></a>02104 
<a name="l02105"></a>02105 <span class="comment">//N=3</span>
<a name="l02106"></a>02106 <span class="comment">//template &lt;class X, class Y, class Param1, class Param2, class Param3, class RetType&gt;</span>
<a name="l02107"></a>02107 <span class="comment">//fast_delegate3&lt;Param1, Param2, Param3, FASTDLGT_RETTYPE&gt; make_fast_delegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3)) { </span>
<a name="l02108"></a>02108 <span class="comment">//  return fast_delegate3&lt;Param1, Param2, Param3, FASTDLGT_RETTYPE&gt;(x, func);</span>
<a name="l02109"></a>02109 <span class="comment">//}</span>
<a name="l02110"></a>02110 <span class="keyword">template</span> &lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y, <span class="keyword">class</span> Param1, <span class="keyword">class</span> Param2, <span class="keyword">class</span> Param3, <span class="keyword">class</span> RetType&gt;
<a name="l02111"></a>02111 fast_delegate&lt;FASTDLGT_RETTYPE (Param1, Param2, Param3)&gt; make_fast_delegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3)) { 
<a name="l02112"></a>02112     <span class="keywordflow">return</span> fast_delegate&lt;FASTDLGT_RETTYPE(Param1, Param2, Param3)&gt;(x, func);
<a name="l02113"></a>02113 }
<a name="l02114"></a>02114 
<a name="l02115"></a>02115 <span class="keyword">template</span> &lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y, <span class="keyword">class</span> Param1, <span class="keyword">class</span> Param2, <span class="keyword">class</span> Param3, <span class="keyword">class</span> RetType&gt;
<a name="l02116"></a>02116 fast_delegate3&lt;Param1, Param2, Param3, FASTDLGT_RETTYPE&gt; make_fast_delegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3) <span class="keyword">const</span>) { 
<a name="l02117"></a>02117     <span class="keywordflow">return</span> fast_delegate3&lt;Param1, Param2, Param3, FASTDLGT_RETTYPE&gt;(x, func);
<a name="l02118"></a>02118 }
<a name="l02119"></a>02119 
<a name="l02120"></a>02120 <span class="comment">//N=4</span>
<a name="l02121"></a>02121 <span class="keyword">template</span> &lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y, <span class="keyword">class</span> Param1, <span class="keyword">class</span> Param2, <span class="keyword">class</span> Param3, <span class="keyword">class</span> Param4, <span class="keyword">class</span> RetType&gt;
<a name="l02122"></a>02122 fast_delegate4&lt;Param1, Param2, Param3, Param4, FASTDLGT_RETTYPE&gt; make_fast_delegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4)) { 
<a name="l02123"></a>02123     <span class="keywordflow">return</span> fast_delegate4&lt;Param1, Param2, Param3, Param4, FASTDLGT_RETTYPE&gt;(x, func);
<a name="l02124"></a>02124 }
<a name="l02125"></a>02125 
<a name="l02126"></a>02126 <span class="keyword">template</span> &lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y, <span class="keyword">class</span> Param1, <span class="keyword">class</span> Param2, <span class="keyword">class</span> Param3, <span class="keyword">class</span> Param4, <span class="keyword">class</span> RetType&gt;
<a name="l02127"></a>02127 fast_delegate4&lt;Param1, Param2, Param3, Param4, FASTDLGT_RETTYPE&gt; make_fast_delegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) <span class="keyword">const</span>) { 
<a name="l02128"></a>02128     <span class="keywordflow">return</span> fast_delegate4&lt;Param1, Param2, Param3, Param4, FASTDLGT_RETTYPE&gt;(x, func);
<a name="l02129"></a>02129 }
<a name="l02130"></a>02130 
<a name="l02131"></a>02131 <span class="comment">//N=5</span>
<a name="l02132"></a>02132 <span class="keyword">template</span> &lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y, <span class="keyword">class</span> Param1, <span class="keyword">class</span> Param2, <span class="keyword">class</span> Param3, <span class="keyword">class</span> Param4, <span class="keyword">class</span> Param5, <span class="keyword">class</span> RetType&gt;
<a name="l02133"></a>02133 fast_delegate5&lt;Param1, Param2, Param3, Param4, Param5, FASTDLGT_RETTYPE&gt; make_fast_delegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5)) { 
<a name="l02134"></a>02134     <span class="keywordflow">return</span> fast_delegate5&lt;Param1, Param2, Param3, Param4, Param5, FASTDLGT_RETTYPE&gt;(x, func);
<a name="l02135"></a>02135 }
<a name="l02136"></a>02136 
<a name="l02137"></a>02137 <span class="keyword">template</span> &lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y, <span class="keyword">class</span> Param1, <span class="keyword">class</span> Param2, <span class="keyword">class</span> Param3, <span class="keyword">class</span> Param4, <span class="keyword">class</span> Param5, <span class="keyword">class</span> RetType&gt;
<a name="l02138"></a>02138 fast_delegate5&lt;Param1, Param2, Param3, Param4, Param5, FASTDLGT_RETTYPE&gt; make_fast_delegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) <span class="keyword">const</span>) { 
<a name="l02139"></a>02139     <span class="keywordflow">return</span> fast_delegate5&lt;Param1, Param2, Param3, Param4, Param5, FASTDLGT_RETTYPE&gt;(x, func);
<a name="l02140"></a>02140 }
<a name="l02141"></a>02141 
<a name="l02142"></a>02142 <span class="comment">//N=6</span>
<a name="l02143"></a>02143 <span class="keyword">template</span> &lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y, <span class="keyword">class</span> Param1, <span class="keyword">class</span> Param2, <span class="keyword">class</span> Param3, <span class="keyword">class</span> Param4, <span class="keyword">class</span> Param5, <span class="keyword">class</span> Param6, <span class="keyword">class</span> RetType&gt;
<a name="l02144"></a>02144 fast_delegate6&lt;Param1, Param2, Param3, Param4, Param5, Param6, FASTDLGT_RETTYPE&gt; make_fast_delegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6)) { 
<a name="l02145"></a>02145     <span class="keywordflow">return</span> fast_delegate6&lt;Param1, Param2, Param3, Param4, Param5, Param6, FASTDLGT_RETTYPE&gt;(x, func);
<a name="l02146"></a>02146 }
<a name="l02147"></a>02147 
<a name="l02148"></a>02148 <span class="keyword">template</span> &lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y, <span class="keyword">class</span> Param1, <span class="keyword">class</span> Param2, <span class="keyword">class</span> Param3, <span class="keyword">class</span> Param4, <span class="keyword">class</span> Param5, <span class="keyword">class</span> Param6, <span class="keyword">class</span> RetType&gt;
<a name="l02149"></a>02149 fast_delegate6&lt;Param1, Param2, Param3, Param4, Param5, Param6, FASTDLGT_RETTYPE&gt; make_fast_delegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) <span class="keyword">const</span>) { 
<a name="l02150"></a>02150     <span class="keywordflow">return</span> fast_delegate6&lt;Param1, Param2, Param3, Param4, Param5, Param6, FASTDLGT_RETTYPE&gt;(x, func);
<a name="l02151"></a>02151 }
<a name="l02152"></a>02152 
<a name="l02153"></a>02153 <span class="comment">//N=7</span>
<a name="l02154"></a>02154 <span class="keyword">template</span> &lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y, <span class="keyword">class</span> Param1, <span class="keyword">class</span> Param2, <span class="keyword">class</span> Param3, <span class="keyword">class</span> Param4, <span class="keyword">class</span> Param5, <span class="keyword">class</span> Param6, <span class="keyword">class</span> Param7, <span class="keyword">class</span> RetType&gt;
<a name="l02155"></a>02155 fast_delegate7&lt;Param1, Param2, Param3, Param4, Param5, Param6, Param7, FASTDLGT_RETTYPE&gt; make_fast_delegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7)) { 
<a name="l02156"></a>02156     <span class="keywordflow">return</span> fast_delegate7&lt;Param1, Param2, Param3, Param4, Param5, Param6, Param7, FASTDLGT_RETTYPE&gt;(x, func);
<a name="l02157"></a>02157 }
<a name="l02158"></a>02158 
<a name="l02159"></a>02159 <span class="keyword">template</span> &lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y, <span class="keyword">class</span> Param1, <span class="keyword">class</span> Param2, <span class="keyword">class</span> Param3, <span class="keyword">class</span> Param4, <span class="keyword">class</span> Param5, <span class="keyword">class</span> Param6, <span class="keyword">class</span> Param7, <span class="keyword">class</span> RetType&gt;
<a name="l02160"></a>02160 fast_delegate7&lt;Param1, Param2, Param3, Param4, Param5, Param6, Param7, FASTDLGT_RETTYPE&gt; make_fast_delegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) <span class="keyword">const</span>) { 
<a name="l02161"></a>02161     <span class="keywordflow">return</span> fast_delegate7&lt;Param1, Param2, Param3, Param4, Param5, Param6, Param7, FASTDLGT_RETTYPE&gt;(x, func);
<a name="l02162"></a>02162 }
<a name="l02163"></a>02163 
<a name="l02164"></a>02164 <span class="comment">//N=8</span>
<a name="l02165"></a>02165 <span class="keyword">template</span> &lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y, <span class="keyword">class</span> Param1, <span class="keyword">class</span> Param2, <span class="keyword">class</span> Param3, <span class="keyword">class</span> Param4, <span class="keyword">class</span> Param5, <span class="keyword">class</span> Param6, <span class="keyword">class</span> Param7, <span class="keyword">class</span> Param8, <span class="keyword">class</span> RetType&gt;
<a name="l02166"></a>02166 fast_delegate8&lt;Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, FASTDLGT_RETTYPE&gt; make_fast_delegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8)) { 
<a name="l02167"></a>02167     <span class="keywordflow">return</span> fast_delegate8&lt;Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, FASTDLGT_RETTYPE&gt;(x, func);
<a name="l02168"></a>02168 }
<a name="l02169"></a>02169 
<a name="l02170"></a>02170 <span class="keyword">template</span> &lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y, <span class="keyword">class</span> Param1, <span class="keyword">class</span> Param2, <span class="keyword">class</span> Param3, <span class="keyword">class</span> Param4, <span class="keyword">class</span> Param5, <span class="keyword">class</span> Param6, <span class="keyword">class</span> Param7, <span class="keyword">class</span> Param8, <span class="keyword">class</span> RetType&gt;
<a name="l02171"></a>02171 fast_delegate8&lt;Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, FASTDLGT_RETTYPE&gt; make_fast_delegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) <span class="keyword">const</span>) { 
<a name="l02172"></a>02172     <span class="keywordflow">return</span> fast_delegate8&lt;Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, FASTDLGT_RETTYPE&gt;(x, func);
<a name="l02173"></a>02173 }
<a name="l02174"></a>02174 
<a name="l02175"></a>02175 
<a name="l02176"></a>02176  <span class="comment">// clean up after ourselves...</span>
<a name="l02177"></a>02177 <span class="preprocessor">#undef FASTDLGT_RETTYPE</span>
<a name="l02178"></a>02178 <span class="preprocessor"></span><span class="comment"></span>
<a name="l02179"></a>02179 <span class="comment">/// @endcond</span>
<a name="l02180"></a>02180 <span class="comment"></span>} } <span class="comment">// namespace boost::idl</span>
<a name="l02181"></a>02181 <span class="preprocessor">#endif // !defined(FASTDELEGATE_H)</span>
<a name="l02182"></a>02182 <span class="preprocessor"></span>
<a name="l02183"></a>02183 
</pre></div></div>
<hr/>
<table border=0 width="100%">
<tr>
<td>
&copy; Daniel Larimer 2010-2011 - Licensed under <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License, Version 1.0</a>
</td>
<td>
</td>
<td align="right">
Boost IDL Library  
</td>
</tr>
</table>
