<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Boost Reflect Library: Remote Procedure Call Case Study</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Remote Procedure Call Case Study</h1><table border="0" cellpadding="0" cellspacing="0">
</table>
<p>This case study is designed to demonstrate the general usefulness of Boost.Reflect by implementing a simple generic RPC system based upon Boost.Serialization. This example shows what is possible, and how Boost.Reflect can serve as the foundation of a more general Boost RPC library.</p>
<h2><a class="anchor" id="rpc_design">
RPC Design Approach</a></h2>
<p>The goal is to provide type-safe remote procedure calls. One solution to this problem is the <a href="http://www.codeproject.com/KB/threads/Rcf_Ipc_For_Cpp.aspx">RCF - Interprocess Communication for C++</a> library discussed at <a href="www.codeproject.com">CodeProject</a>.</p>
<p>Lets review their approach first:</p>
<p>Server: </p>
<div class="fragment"><pre class="fragment">    RCF_BEGIN(I_Echo, <span class="stringliteral">&quot;I_Echo&quot;</span>)
        RCF_METHOD_R1(std::<span class="keywordtype">string</span>, echo, const std::<span class="keywordtype">string</span> &amp;)
    RCF_END(I_Echo)

    struct Echo
    {
        std::string echo(<span class="keyword">const</span> std::string &amp;s) { <span class="keywordflow">return</span> s; }
    };

    <span class="keywordtype">int</span> main()
    {
        Echo echo;
        RCF::RcfServer server(RCF::TcpEndpoint(50001));
        server.bind&lt;I_Echo&gt;(echo);
        server.startInThisThread();
        <span class="keywordflow">return</span> 0;
    }
</pre></div><p>Client: </p>
<div class="fragment"><pre class="fragment">    RCF_BEGIN(I_Echo, <span class="stringliteral">&quot;I_Echo&quot;</span>)
        RCF_METHOD_R1(std::<span class="keywordtype">string</span>, echo, const std::<span class="keywordtype">string</span> &amp;)
    RCF_END(I_Echo)

    <span class="keywordtype">int</span> main()
    {
        RcfClient&lt;I_Echo&gt; echoClient(RCF::TcpEndpoint(<span class="stringliteral">&quot;localhost&quot;</span>, 50001));
        std::string s = echoClient.echo(RCF::Twoway, <span class="stringliteral">&quot;what&#39;s up&quot;</span>);
        <span class="keywordflow">return</span> 0;
    }
</pre></div><p>While this only shows a simple example, it should communicate approximately what the API is.</p>
<p>Now lets compare what the target Boost.Reflect based API would be:</p>
<p>Server: </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">struct </span>Echo
    {
        std::string echo(<span class="keyword">const</span> std::string &amp;s) { <span class="keywordflow">return</span> s; }
    };
    BOOST_Reflect_INTERFACE( Echo, BOOST_Reflect_BASE, (echo) )
        
    int main()
    {
        boost::reflect::rpc_server&lt;Echo&gt; server( Echo() );
        server.listen( 50001 );
        <span class="keywordflow">return</span> 0;
    }
</pre></div><p>Client: </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">struct </span>Echo
    {
        std::string echo(<span class="keyword">const</span> std::string &amp;s); <span class="comment">// implementation not needed</span>
    };
    BOOST_Reflect_INTERFACE( Echo, BOOST_Reflect_BASE, (echo) )
        
    int main()
    {
        boost::reflect::rpc_client&lt;Echo&gt; client; 
        client.connect_to( <span class="stringliteral">&quot;localhost&quot;</span>, 50001 );
        std::string s = client.echo( <span class="stringliteral">&quot;what&#39;s up&quot;</span> );
        <span class="keywordflow">return</span> 0;
    }
</pre></div><p>Some improvements offered by Boost.Reflect is that the return value and parameter types are only specified once. But the real power of Boost.Reflect is that it allows type erasure to apply to the rpc_client&lt;&gt; and thus we can turn this client in to a fully functional command line interface to a remote server with the following change:</p>
<div class="fragment"><pre class="fragment">    cli  m_cli;
    m_cli.start_visit(client);

    <span class="comment">// erase the details of the rpc_client, by storing</span>
    <span class="comment">// it in a generic Echo interface.</span>
    boost::reflect::any&lt;Echo&gt; any_echo = client;

    std::string line;
    std::string cmd;
    std::string args;

    <span class="keywordflow">while</span>( <span class="keyword">true</span> )
    {
        std::cerr &lt;&lt; <span class="stringliteral">&quot;Enter Method: &quot;</span>;
        std::getline( std::cin, line );
        cmd = line.substr( 0, line.find(<span class="charliteral">&#39;(&#39;</span>) );
        args = line.substr( cmd.size(), line.size() );
        std::cerr &lt;&lt; m_cli[cmd](args) &lt;&lt; std::endl;
    }
</pre></div><h2><a class="anchor" id="implement_rpc_server">
Implementing RPC Server</a></h2>
<p>The server is a boost::reflect::any&lt;InterfaceType&gt; that also implements the visitor pattern. It creates a map from method name to a geneirc function that takes a serialized string for arguments and returns a serialized string as return value.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>boost { <span class="keyword">namespace </span>reflect {
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> InterfaceType&gt;
<span class="keyword">class </span>rpc_server : <span class="keyword">public</span> boost::reflect::visitor&lt; rpc_server&lt;InterfaceType&gt; &gt;, 
                   <span class="keyword">public</span> reflect::any&lt;InterfaceType&gt;
{
    <span class="keyword">public</span>:
       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
       rpc_server( T v )
       :reflect::any&lt;InterfaceType&gt;(v)
       {
            <span class="comment">// initialize ourself</span>
            start_visit(*<span class="keyword">this</span>); 
       }

       <span class="comment">// starts an endless loop waiting for commands</span>
       <span class="keywordtype">void</span> listen( uint16_t port )
       {
            <span class="keyword">using namespace </span>boost::asio::ip;
            boost::asio::io_service io_service;
            udp::socket  socket( io_service, udp::endpoint(udp::v4(), port ) );
            std::vector&lt;char&gt;  recv_buf(2048);
            <span class="keywordflow">for</span>( ;; )
            {
                udp::endpoint remote_ep;
                boost::system::error_code err;
                <span class="keywordtype">size_t</span> bytes_recv = socket.receive_from( boost::asio::buffer(recv_buf),
                                     remote_ep, 0, err );
                <span class="keywordflow">if</span>( err &amp;&amp; err != boost::asio::error::message_size )
                    <span class="keywordflow">throw</span> boost::system::system_error(err);

                <span class="comment">// unpack the message which contains two strings, method name and params.</span>
                std::string         buf(&amp;recv_buf.front(),bytes_recv );
                std::string         method;
                std::string         params;
                {
                    std::istringstream iss( buf );
                    boost::archive::binary_iarchive ia(iss);
                    ia &gt;&gt; method;
                    ia &gt;&gt; params;
                }
                boost::system::error_code ignored_error;

                <span class="comment">// call methods[method] with params and reply with a message that contains</span>
                <span class="comment">// the serailized return value.</span>
                socket.send_to( boost::asio::buffer( methods[method](params) ),
                                remote_ep, 0, ignored_error );
            }
       }

       <span class="comment">// for each functor on the InterfaceType, create an rpc_functor</span>
       <span class="comment">// that converts serailized params to their actual values, invokes</span>
       <span class="comment">// the method, and converts the return value to a serailized buffer.</span>
       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> InterfaceName, <span class="keyword">typename</span> M&gt;
       <span class="keywordtype">bool</span> accept( M&amp; m, <span class="keyword">const</span> <span class="keywordtype">char</span>* name )
       {
            methods[name] = rpc_functor&lt;typename M::fused_params, M&amp;&gt;(m);
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
       }
       boost::function&lt;std::string(const std::string)&gt;&amp; operator[]( <span class="keyword">const</span> std::string&amp; name ) 
       { <span class="keywordflow">return</span> methods[name]; }

    <span class="keyword">private</span>:

       <span class="comment">// Seq is a boost::fusion::vector&lt;PARAM TYPES&gt;</span>
       <span class="comment">// Functor is a reference to the member function object.</span>
       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq, <span class="keyword">typename</span> Functor&gt;
       <span class="keyword">struct </span>rpc_functor
       {
           rpc_functor( Functor f )
           :m_func(f){}

           <span class="comment">// this method does the actual work of converting params to</span>
           <span class="comment">// the proper types, invoking the Functor, and returning the</span>
           <span class="comment">// serialized return value.</span>
           std::string operator()( <span class="keyword">const</span> std::string&amp; params )
           {
                Seq paramv;
                std::istringstream is(params);
                {
                    boost::archive::binary_iarchive ia(is);
                    deserialize_fusion_vector(ia,paramv);                    
                }
                std::ostringstream os;
                {
                    boost::archive::binary_oarchive oa(os);
                    <span class="keyword">typename</span> boost::remove_reference&lt;Functor&gt;::type::result_type r = m_func(paramv);
                    oa &lt;&lt; r;
                }
                <span class="keywordflow">return</span> os.str();
           }
           Functor m_func;
       };

       std::map&lt;std::string, boost::function&lt;std::string(const std::string)&gt; &gt; methods;
};

} } <span class="comment">// namespace boost::reflect</span>
</pre></div><h2><a class="anchor" id="implement_rpc_client">
Implementing RPC Client</a></h2>
<p>The RPC Client needs to define a new object that implements the interface in such a way that it sends the method name and serialized parameters over a socket. In this case, the implementation of the interface is fully dynamic.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InterfaceType&gt;
<span class="keyword">class </span>rpc_client : <span class="keyword">public</span> boost::reflect::visitor&lt; rpc_client&lt;InterfaceType&gt; &gt;, <span class="keyword">public</span> reflect::any&lt;InterfaceType&gt;
{
    <span class="keyword">public</span>:
       rpc_client()
       :m_ios(),m_sock(m_ios)
       {
           start_visit(*<span class="keyword">this</span>);
       }

       <span class="keywordtype">bool</span> connect_to( <span class="keyword">const</span> std::string&amp; host, uint16_t port )
       {
           m_sock.open(boost::asio::ip::udp::v4());
           m_ep = boost::asio::ip::udp::endpoint( boost::asio::ip::address::from_string(host), port );
       }

       <span class="comment">// this method does the actual work of sending a method/params across the socket</span>
       <span class="comment">// it is called by the rpc_client::rpc_functor which serailizes the values.</span>
       std::string invoke( <span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keyword">const</span> std::string&amp; params )
       {
            std::ostringstream os;
            {  
                boost::archive::binary_oarchive oa(os);
                std::string n(name);
                oa &lt;&lt; n;
                oa &lt;&lt; params;
            }
            m_sock.send_to( boost::asio::buffer( os.str() ), m_ep );
            boost::asio::ip::udp::endpoint rep;
            std::vector&lt;char&gt; recv_buf(2048);
            <span class="keywordtype">size_t</span> len = m_sock.receive_from( boost::asio::buffer(recv_buf), rep );
            <span class="keywordflow">return</span> std::string(&amp;recv_buf.front(),len);
       }

       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> InterfaceName, <span class="keyword">typename</span> M&gt;
       <span class="keywordtype">bool</span> accept( M&amp; m, <span class="keyword">const</span> <span class="keywordtype">char</span>* name )
       {
            m.m_delegate = rpc_functor&lt;typename M::fused_params, typename M::result_type&gt;(*<span class="keyword">this</span>,name);
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
       }

   <span class="keyword">private</span>:
       <span class="comment">// stores a pointer to the name and rpc_client and is responsible</span>
       <span class="comment">// for serialization/deserialization</span>
       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq, <span class="keyword">typename</span> ResultType&gt;
       <span class="keyword">struct </span>rpc_functor
       {
           rpc_functor( rpc_client&amp; c, <span class="keyword">const</span> <span class="keywordtype">char</span>* name )
           :m_client(c),m_name(name){}

            <span class="comment">// The input is the parameters passed to the method as a boost::fusion::vector&lt;&gt;</span>
            <span class="comment">// The result is the deserialized response from the remote client.</span>
           ResultType operator()( <span class="keyword">const</span> Seq&amp; params )
           {
                std::ostringstream os;
                {  
                    boost::archive::binary_oarchive oa(os);
                    serialize_fusion_vector(oa, params);
                }
                ResultType  ret_val;
                std::istringstream is(m_client.invoke( m_name, os.str() ) );
                {
                    boost::archive::binary_iarchive ia(is);
                    ia &gt;&gt; ret_val;
                }
                <span class="keywordflow">return</span> ret_val;
           }
           <span class="keyword">const</span> <span class="keywordtype">char</span>* m_name;
           rpc_client&amp; m_client;
       };
       boost::asio::ip::udp::endpoint m_ep;
       boost::asio::io_service        m_ios;
       boost::asio::ip::udp::socket   m_sock;
       std::map&lt;std::string, boost::function&lt;std::string(const std::string)&gt; &gt; methods;
};
</pre></div> </div>
<hr/>
<table border=0 width="100%">
<tr>
<td>
&copy; Daniel Larimer 2010-2011 - Licensed under <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License, Version 1.0</a>
</td>
<td>
</td>
<td align="right">
Boost Reflect Library  
</td>
</tr>
</table>
<script type="text/javascript">

  var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-2423876-2']);
      _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
                      })();

                      </script>
