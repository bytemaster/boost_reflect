<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Boost Reflect Library: Quick Start</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Quick Start<br/>
<small>
[<a class="el" href="group__boost__reflect.html">Boost.Reflect</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
</table>
<p>There are two primary uses for the Boost.Reflect library:</p>
<ul>
<li>Visiting members on a type.</li>
<li>Creating type erasures for an interface</li>
</ul>
<h2><a class="anchor" id="boost_reflect_basic">
Basic Reflection</a></h2>
<p>Basic reflection of a type is achieved using the <a class="el" href="reflect_8hpp.html#a90309261db059f46860d655ed351013d">BOOST_REFLECT(TYPE,INHERITS,MEMBERS)</a> macro to specify base classes and class members. Below is an example of reflecting a struct.</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">struct </span>my_struct {
        <span class="keywordtype">int</span>         hello;
        std::string world;
    };
    <a class="code" href="old_8hpp.html#ac349b37ce6abc17c2c5e556a6368acb2" title="Specializes boost::reflect::reflector for TYPE.">BOOST_REFLECT</a>( my_struct, (hello)(world) )
</pre></div><p>Now that we have reflected the struct, we can dump it to XML with a simple visitor.</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
    <span class="keyword">struct </span>xml_printer {
        xml_printer( <span class="keyword">const</span> T&amp; c ):self(c){}

        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Class, <span class="keyword">typename</span> Member&gt;
        <span class="keywordtype">void</span> operator()( Member Class::*p, <span class="keyword">const</span> <span class="keywordtype">char</span>* name ) {
            std::cerr&lt;&lt;<span class="stringliteral">&quot;&lt;&quot;</span>&lt;&lt;name&lt;&lt;<span class="stringliteral">&quot;&gt;&quot;</span>&lt;&lt;(<span class="keyword">self</span>.*p)&lt;&lt;<span class="stringliteral">&quot;&lt;/&quot;</span>&lt;&lt;name&lt;&lt;<span class="stringliteral">&quot;&gt;\n&quot;</span>;
        }
        <span class="keyword">const</span> T&amp; <span class="keyword">self</span>;
    };
</pre></div><p>The visitor can then be applied like so: </p>
<div class="fragment"><pre class="fragment">        my_struct s;
        <a class="code" href="structboost_1_1reflect_1_1reflector.html#ad7e2371eee574b5bbd1a0237204634d2">boost::reflect::reflector&lt;my_struct&gt;::visit</a>( xml_printer(s) );
</pre></div><h2><a class="anchor" id="boost_reflect_erasures">
Type Erasures</a></h2>
<p>Type Erasure is one means to hide implementation details by defining a type that can contain any object that implements the required interface. Examples are boost::any and boost::function. Boost.Reflect enables the rapid generation of new type erasures for arbitrary interfaces via the <a class="el" href="classboost_1_1reflect_1_1any__ptr.html">any_ptr&lt;Interface&gt; </a> type.</p>
<p><a class="el" href="classboost_1_1reflect_1_1any__ptr.html" title="Behaves like a smart pointer that can handle any type with the same interface.">boost::reflect::any_ptr</a> can hold a pointer or shared pointer to any type that implements a particular reflected interface.</p>
<p>Here is an example on how to define a new type erasure for two interfaces, Service and Calculator.</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">struct </span>Service {
      std::string name()<span class="keyword">const</span>;
      <span class="keywordtype">int</span>         exit();
    };
    <span class="keyword">struct </span>Calculator : Service {
      <span class="keywordtype">double</span> add( <span class="keywordtype">double</span> v );           
      <span class="keywordtype">double</span> sub( <span class="keywordtype">double</span> v );           
      <span class="keywordtype">double</span> mult( <span class="keywordtype">double</span> v );           
      <span class="keywordtype">double</span> div( <span class="keywordtype">double</span> v );           
      <span class="keywordtype">double</span> result()<span class="keyword">const</span>;
    };

    <a class="code" href="vtable_8hpp.html#a800b79c6db12c7d5daf890912c5e8cf1">BOOST_REFLECT_ANY</a>( Service,(name)(exit) )
    <a class="code" href="vtable_8hpp.html#a02f144061854c3535f18367805c7e293">BOOST_REFLECT_ANY_DERIVED</a>( Calculator, (Service), (add)(sub)(mult)(div)(result) )
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>When you define an interface, you need not provide implementations of the methods; however, if you want you may also use an interace like any other class without limititations.</dd></dl>
<div class="fragment"><pre class="fragment">    <span class="keyword">class </span>CalculatorService {
      <span class="keyword">public</span>:
        CalculatorService():m_result(0){}

        std::string name()<span class="keyword">const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;CalculatorService&quot;</span>; }
        <span class="keywordtype">int</span>   exit()            { ::exit(0);                  }
        <span class="keywordtype">double</span> add( <span class="keywordtype">double</span> v )  { <span class="keywordflow">return</span> m_result += v;       }
        <span class="keywordtype">double</span> sub( <span class="keywordtype">double</span> v )  { <span class="keywordflow">return</span> m_result -= v;       }
        <span class="keywordtype">double</span> mult( <span class="keywordtype">double</span> v ) { <span class="keywordflow">return</span> m_result *= v;       }
        <span class="keywordtype">double</span> div( <span class="keywordtype">double</span> v )  { <span class="keywordflow">return</span> m_result /= v;       }
        <span class="keywordtype">double</span> result()<span class="keyword">const    </span>{ <span class="keywordflow">return</span> m_result;            }

      <span class="keyword">private</span>:
        <span class="keywordtype">double</span> m_result;
    };

    <span class="keywordtype">void</span> try_it() {
      reflect::any_ptr&lt;Calculator&gt; calc( <span class="keyword">new</span> CalculatorService() );
      calc-&gt;add(5);
      calc-&gt;add(6);
      std::string name = calc-&gt;name();
      assert( calc-&gt;result() == 11 );
    }
</pre></div><p>Some things to note, CalculatorService did not inherit either Calculator or Service, it simply exposed all of the methods defined by the interface. If it looks like a Duck, quacks like a Duck, then it is a Duck.</p>
<p>The interface of any_ptr&lt;Calculator&gt; is 'identical' to the Calculator defined above.</p>
<p>Pointer semantics were chosen to discourage using reflect::anys as values where assignment and copy construction creates a new instance. Initialization of <a class="el" href="classboost_1_1reflect_1_1any__ptr.html">any_ptr </a> with a new pointer is a relatively expensive operation and value semantics would create objects that are much bigger and more expensive to copy than traditional types as each method is a functor that must be initialized at copy/construction time.</p>
<p>Generally speaking, any_ptr&lt;&gt; should be used to abstract long-lived objects and not for temporaries. </p>
</div>
<hr/>
<table border=0 width="100%">
<tr>
<td>
&copy; Daniel Larimer 2010-2011 - Licensed under <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License, Version 1.0</a>
</td>
<td>
</td>
<td align="right">
Boost Reflect Library  
</td>
</tr>
</table>
<script type="text/javascript">

  var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-2423876-2']);
      _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
                      })();

                      </script>
